<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Pin: Utilities for formatting strings</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.6 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="modules.html"><span>Modules</span></a></li>
    <li><a href="classes.html"><span>Classes</span></a></li>
    <li>
      <form action="search.php" method="get">
        <table cellspacing="0" cellpadding="0" border="0">
          <tr>
            <td><label>&nbsp;<u>S</u>earch&nbsp;for&nbsp;</label></td>
            <td><input type="text" name="query" value="" size="20" accesskey="s"/></td>
          </tr>
        </table>
      </form>
    </li>
  </ul></div>
<h1>Utilities for formatting strings</h1><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">This module contains routines <br>
and classes for the&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MISC__PRINT.html#g5812709dfe32fdd9b67c62927dd07318">handling</a> (error) messages */namespace LEVEL_BASE</td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
<dl compact><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT &amp; Probe<br>
 <b>O/S</b>: Linux &amp; Windows<br>
 <b>CPU:</b> IA-32 and Intel(R) 64 architectures<br>
 </dd></dl>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="g5812709dfe32fdd9b67c62927dd07318"></a><!-- doxytag: member="util.cpp::handling" ref="g5812709dfe32fdd9b67c62927dd07318" args="(error) messages */namespace LEVEL_BASE" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">This module contains routines and classes for the handling           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">error&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Given a command line (sub)string, find and parse its first argument. Parsing rules (see MS CRT): File names =========== Quoted string -&gt; non-quoted string (quotes are not copied)<p>
Regular argument ================ 2N backslashes + " -&gt; N backslashes + begin/end quoted string (quote is not copied) 2N+1 backslashes + " -&gt; N backslashes + literal " " + " in a quoted string -&gt; single literal " all other combinations of symbols are copied as is<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>cmdPtr</em>&nbsp;</td><td>pointer to the command line (sub)string </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>isFile</em>&nbsp;</td><td>TRUE - use parsing rules for file name FALSE - use parsing rules for regular argument </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>buf</em>&nbsp;</td><td>buffer that receives argument after parsing. If this parameter is NULL, the argument is not copied. If the buffer is too small, the terminating NULL is not copied into the buffer. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>bufSize</em>&nbsp;</td><td>size of the buffer; ignored if &lt;buf&gt; is NULL. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>pArgSize</em>&nbsp;</td><td>pointer to variable that receives size of the argument to be copied into the buffer, not including terminating NULL. If this parameter is NULL, the argument size is not returned. Otherwise, the size value is returned even if &lt;buf&gt; is NULL. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>pNextPtr</em>&nbsp;</td><td>pointer to variable that receives pointer to the command line substring following the found attribute. If this parameter is NULL, the pointer is not returned. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>pointer to the first argument found in the specified command line (sub)string or NULL.</dd></dl>
Given pin's command line, return substring containing application's command line. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>pinCmdLine</em>&nbsp;</td><td>command line of pin exe process. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>pointer to substring containing application's command line; NULL, if application's command line is not found</dd></dl>
Split string into 2 sub strings. Example1: prefix = SplitString(input = "aaa bbb ccc", " ") -&gt; prefix = "aaa", input = "bbb ccc" Example2: prefix = SplitString(input = "aaa", " ") -&gt; prefix = "aaa", input = ""<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>inout]</em>&nbsp;</td><td>input - input string. remove prefix and set the new string into input. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>delimiter</em>&nbsp;</td><td>- delimiter</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>prefix string</dd></dl>
class that represents command line arguments<p>
Empty Constructor<p>
Constructor. Construct an object from argc, argv and delimiter Example1: argc = 6, argv = {ab bc cd de ef de}, delimiter = "de" =&gt; the object will contain: argc = 4, argv = {ab bc cd de} Example2: argc = 6, argv = {ab bc cd de ef de}, delimiter = NULL =&gt; the object will contain: argc = 6, argv = {ab bc cd de ef de} Example3: argc = 6, argv = {ab bc cd de ef de}, delimiter = "fg" =&gt; the object will contain: argc = 6, argv = {ab bc cd de ef de}<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>argc</em>&nbsp;</td><td>argc for the command line arguments object </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>argv</em>&nbsp;</td><td>argv for the command line arguments object </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>delimiter</em>&nbsp;</td><td>remove any argv argument AFTER the delimiter. If it was not found, nothing will be removed</td></tr>
  </table>
</dl>
Constructor. Construct an object from a string using MS CRT Parsing rules (For more details see GetCmdArg() documentation)<p>
NOTE: Use this function only for original application's command line<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>commandLine</em>&nbsp;</td><td>original application's command line represented as string</td></tr>
  </table>
</dl>
Copy Constructor. Construct an object from another object<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>source</em>&nbsp;</td><td>source object</td></tr>
  </table>
</dl>
Assignment operator<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>source</em>&nbsp;</td><td>source object</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>reference to current object</dd></dl>
Append an object to current object (in the end of current object)<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>right</em>&nbsp;</td><td>object to be appended</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>reference to current object</dd></dl>
Append an argument to current object (in the end of current object)<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>arg</em>&nbsp;</td><td>an argument to be appended</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>reference to current object</dd></dl>
Find an argument by name<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>argStr</em>&nbsp;</td><td>- argument to be found</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>index of argument or -1 if not found</dd></dl>
Looks for argument equal to argStr; remove "numOfArgs" arguments starting from the found argument<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>argStr</em>&nbsp;</td><td>- argument to be found, </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>numOfArgs</em>&nbsp;</td><td>- numer of arguments that should be removed starting from the found argument</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>TRUE if numOfArgs were removed from the list<p>
Argc of current object the value life time is as long as the object was not changed (using operator=(), Append() or ~COMMAND_LINE_ARGUMENTS() will invalidate this data)<p>
Argv of current object, the pointer life time is as long as the object was not changed (using operator=(), Append() or ~COMMAND_LINE_ARGUMENTS() will invalidate this data)<p>
string with all command line arguments separated with \" \"</dd></dl>
Destructor<p>
Initialize the object using argc, argv and delimiter<p>
Initialize the object using commandLine string<p>
Deallocate all resources used by current object<p>
Find array size using argc, argv and delimiter<p>
Remove argument by index (0 &lt;= index &lt; m_argc)<p>
&lt; size of argv array<p>
&lt; CHAR* array<p>
Set mode for printing of addresses, two formats are available either 0x12345678 or #1234_5678<p>
ctype::isspace alternative (avoids complications from including ctype.h)<p>
ctype::toupper alternative (avoids complications from including ctype.h)<p>
print pointer<p>
convert a UINT64 into a string using the hex address format<p>
convert a UINT64 into a dec string. Padding can be specified as well<p>
convert a UINT64 into a dec string. Padding can be specified as well<p>
Convert an array of integers to string, separated by spaces.<p>
convert a UINT64 into a dec string with 1000 separation . Padding can be specified as well<p>
add new lines to string to make it fit given line width restrictions<p>
convert a UINT64 into a hex string. Padding can be specified as well<p>
convert a FLT into a string. Padding can be specified as well<p>
convert a BOOL into a string.<p>
convert a TRI into a string.<p>
convert a string to a INT32<p>
convert a string to a UINT32<p>
convert a string to a UINT64<p>
convert a string to a FLT64<p>
Convert specified character to the corresponding hexadecimal digit <dl compact><dt><b>Returns:</b></dt><dd>integer in the interval [0, 15] or -1 upon failure</dd></dl>
Convert a string to an ADDRINT<p>
popcount/bitcount code using the usual trick<p>
read a line from file while maintaining a current line count skiping over blank and comment lines.<p>
break a line into tokens separated by whitespace return them in 'array'<p>
x<p>
x<p>
x<p>
x<p>
x<p>
x<p>
x<p>
x<p>
x<p>
x<p>
x<p>
x<p>
x<p>
x<p>
x<p>
left justify string<p>
convert ADDRINT to "void *"<p>
convert "void *" to ADDRINT<p>
convert "void *" to ADDRINT<p>
Round integer of type &lt;T&gt; up to the next power of two.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>size</em>&nbsp;</td><td>the integer (in bytes).</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Returns the smallest power of two which is greater than or equal to size.</dd></dl>
Round integer of type &lt;T&gt; up to given alignment.<p>
Specialization of the RoundUp function for pointer type<p>
Round integer of type &lt;T&gt; up to given alignment. The alignment must be power of two.<p>
Specialization of the RoundUpPowerOf2 function for pointer type<p>
Round integer of type &lt;T&gt; down to given alignment.<p>
Specialization of the RoundDown function for pointer type<p>
Round integer of type &lt;T&gt; down to given alignment. The alignment must be power of two.<p>
Specialization of the RoundDownPowerOf2 function for pointer type<p>
Convert a pointer to an ADDRINT.<p>
Convert an ADDRINT to a pointer.<p>
convert "void *" to int<p>
integer bit width check<p>
Sign extend from origSize to extendedSize and check if it fits in a field of extendedSize<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>value</em>&nbsp;</td><td>- value to whose size we are checking </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>origSize</em>&nbsp;</td><td>- position of sign bit in value </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>extendedSize</em>&nbsp;</td><td>- size extend to this size, if 0 then extendedSize is origSize</td></tr>
  </table>
</dl>
Wrapper for 3-arg SignedImmediateFits()<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>value</em>&nbsp;</td><td>the value to whose size we are checking </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>origSize</em>&nbsp;</td><td>where to look for the sign bit (typically 8,16,32 or 64) </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>true if sign extending from origSize to extendedSize will not change value</dd></dl>
Internal helper for HashData().<p>
Specialization for optimization (1 byte data size).<p>
Specialization for optimization (2 byte data size).<p>
Specialization for optimization (4 byte data size).<p>
Specialization for optimization (8 byte data size).<p>
Function to incrementally construct a hash value.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>prevHash</em>&nbsp;</td><td>Previous hash value (or zero) </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>data</em>&nbsp;</td><td>New data item to include in hash value.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Returns the new hash value.</dd></dl>
helper function for pin command line argument processing<p>
another pin helper function for command line arguments<p>
Determine if the fileName has the BaseName baseNameToCheckFor On Windows comparison is case-insensitive, others are case sensitive <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>fileName</em>&nbsp;</td><td>The file name that is to be checked </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>baseNameToCheckFor</em>&nbsp;</td><td>Check if the file name has this name as it's filename<ul>
<li>e.g. "kernel32.dll"</li></ul>
</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>true if the file name has specified baseNameToCheckFor as it's base name</dd></dl>
Get the address of the page that addr is in<p>
Return the entry point of a program (either that of the main image or of the dynamic loader)<p>
Concatenate two strings with a path delimiter<p>
Strip the path information<p>
Create a temporary file name<p>
<dl compact><dt><b>Returns:</b></dt><dd>current stack pointer</dd></dl>
Return offset, in bytes, of &lt;ptr1&gt; from &lt;ptr2&gt;<p>
Return pointer whose offset, in bytes, from &lt;ptr&gt; is &lt;offset&gt;<p>
Push data into stack and return updated value of top of stack the stack is growing to the lower addresses <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>stack</em>&nbsp;</td><td>top of stack </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>data</em>&nbsp;</td><td>pointer to the data to be copied </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>alignment</em>&nbsp;</td><td>new value of top of stack suppose to be aligned on "alignment" value, in bytes. the value has to be power of 2 </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>size</em>&nbsp;</td><td>size of the data, in bytes </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>updated value of top of stack</dd></dl>
Push ADDRINT value into stack and return updated value of top of stack <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>stack</em>&nbsp;</td><td>top of stack </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>value</em>&nbsp;</td><td>value to be pushed </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>updated value of top of stack</dd></dl>
Class that represents a memory range - interval of addresses in the virtual address space. <dl compact><dt><b>Note:</b></dt><dd>The range that spans the entire address space can not be represented by this class. Whenever a function of this class should construct such range (logically), an empty range is returned instead.</dd></dl>
Get the page that contains the specified address <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>addr</em>&nbsp;</td><td>address inside the requested page </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>one-page range that contains the specified address</dd></dl>
Get the page that contains the specified address <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>addr</em>&nbsp;</td><td>address inside the requested page </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>one-page range that contains the specified address</dd></dl>
Utility class intended to help in implementing functions that perform their action only "once", when called for the first time. The functions are assumed to return BOOL or VOID. <dl compact><dt><b>Note:</b></dt><dd>the class is not multithread safe. USAGE: ONCE_STATE fooState; BOOL foo() { if (!fooState.Enter()) {return fooState.IsSuccess();} ..... return fooState.Exit(FALSE); ..... return fooState.Exit(TRUE); }</dd></dl>
&lt; initial state - function never executed<p>
&lt; function is currently running<p>
&lt; function executed successfully<p>
&lt; function executed but failed<p>
Deleter class. Defines a static templated method D::Delete(T *) for deleting objects of type &lt;T&gt;. Used as an argument in the COUNTED_PTR template.<p>
Deleter class. Defines a static templated method D::Delete(T *) for deleting arrays of of elements of type &lt;T&gt;. Used as an argument in the COUNTED_PTR template.<p>
Simple non-intrusive implementation of the reference counted (shared) pointer. The implementation does not guarantee neither thread safety nor exception safety. It defines only bare minimum of methods and operators. TEMPLATE ARGUMENTS: T - value type of this template. D - deleter class that defines a static method D::Delete(T *) for deleting objects or arrays of type &lt;T&gt;. OBJECT_DELETER and ARRAY_DELETER are examples of the deleter class.<p>
Constructors. WARNING: do not use the same raw pointer to construct more than one COUNTED_PTR object<p>
Destructor.<p>
Assignment.<p>
Accessors.<p>
Comparison.<p>
Total net bytes allocated by RawMmap and RawMunmap. This must be global because another stats are normalized to this value. The actual value is kept as a local variable in sysfuncs_* and updated by UpdateRawMmapBytes to avoid accessing this variable before the constructor has run.<p>
Total net bytes reserved.<p>
Unattributed allocations<p>
Get StatRawMmapBytes - the number of bytes allocated by Pin. Note that this returns bytes currently allocated, not all bytes that have ever been allocated. Basically, this value will rise and fall during execution.<p>
Update StatRawMmapBytes from a local variable. We can't update the stat directly in RawMmap because it might be called before the constructor for the stat has been executed.<p>
A function calling all malloc-related functions. Calling PullinPinMalloc() in pin and pinclient forces the dynamic loader to pull in the Pin's malloc.<p>
Find value of environment variable     </td>
  </tr>
</table>
<hr size="1"><address style="align: right;"><small>Generated on Wed Dec 3 03:11:38 2008 for Pin by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.6 </small></address>
</body>
</html>
