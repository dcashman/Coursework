<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Pin: Pin 2.5 User Guide</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.6 -->
<div class="tabs">
  <ul>
    <li id="current"><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="modules.html"><span>Modules</span></a></li>
    <li><a href="classes.html"><span>Classes</span></a></li>
    <li>
      <form action="search.php" method="get">
        <table cellspacing="0" cellpadding="0" border="0">
          <tr>
            <td><label>&nbsp;<u>S</u>earch&nbsp;for&nbsp;</label></td>
            <td><input type="text" name="query" value="" size="20" accesskey="s"/></td>
          </tr>
        </table>
      </form>
    </li>
  </ul></div>
<h1>Pin 2.5 User Guide</h1>
<p>
======================================================================================== <h2><a class="anchor" name="INTRO">
Introduction</a></h2>
========================================================================================<p>
Pin is a tool for the instrumentation of programs. It supports Linux* and Windows* executables for IA-32, Intel(R) 64, and IA-64 architectures.<p>
Pin allows a tool to insert arbitrary code (written in C or C++) in arbitrary places in the executable. The code is added dynamically while the executable is running. This also makes it possible to attach Pin to an already running process.<p>
Pin provides a rich API that abstracts away the underlying instruction set idiosyncracies and allows context information such as register contents to be passed to the injected code as parameters. Pin automatically saves and restores the registers that are overwritten by the injected code so the application continues to work. Limited access to symbol and debug information is available as well.<p>
Pin includes the source code for a large number of example instrumentation tools like basic block profilers, cache simulators, instruction trace generators, etc. It is easy to derive new tools using the examples as a template.<p>
Table of Contents<ul>
<li><a class="el" href="index.html#OVERVIEW">Overview</a> Description of how to instrument with Pin</li><li><a class="el" href="index.html#EXAMPLES">Examples</a> Example tools and explanation</li><li><a class="el" href="index.html#INSTALLATION">Installation</a> Instructions for installing Pin</li><li><a class="el" href="index.html#RESTRICTIONS">Restrictions</a> Unsupported features and restrictions</li><li><a class="el" href="group__API__REF.html">Pin API reference</a> Detailed descriptions of the API</li><li><a class="el" href="group__KNOBS.html">Pin Command Line Switches</a> Descriptions of the command line switches</li><li><a class="el" href="group__INSTLIB.html">Instrumentation Library</a> Library for common instrumentation tasks</li><li><a class="el" href="index.html#DEBUGGING">Debugging Tips for debugging a Pintool</a></li><li><a class="el" href="index.html#LOGGING">Logging</a> Recording messages from a Pintool</li><li><a class="el" href="index.html#PERFORMANCE">Performance Consideration</a> when writing a Pintool</li><li><a class="el" href="index.html#EXTRA_WINDOWS">Additional information for Windows</a></li><li><a class="el" href="index.html#WINLIBRARIES">Libraries for Windows</a></li><li><a class="el" href="index.html#LIBRARIES">Libraries for Linux</a></li><li><a class="el" href="index.html#RESTRICTIONS">Unsupported features and restrictions</a></li><li><a class="el" href="index.html#FEEDBACK">Feedback</a> Questions? Bugs?</li><li><a class="el" href="index.html#LEGAL">Disclaimer and Legal Information</a></li></ul>
<p>
======================================================================================== <h2><a class="anchor" name="OVERVIEW">
Overview</a></h2>
========================================================================================<h3><a class="anchor" name="Pin">
Pin</a></h3>
The best way to think about Pin is as a "just in time" (JIT) compiler. The input to this compiler is not bytecode, however, but a regular executable. Pin intercepts the execution of the first instruction of the executable and generates ("compiles") new code for the straight line code sequence starting at this instruction. It then transfers control to the generated sequence. The generated code sequence is almost identical to the original one, but Pin ensures that it regains control when a branch exits the sequence. After regaining control, Pin generates more code for the branch target and continues execution. Pin makes this efficient by keeping all of the generated code in memory so it can be reused and directly branching from one sequence to another.<p>
The only code ever executed is the generated code. The original code is only used for reference. When generating code, Pin gives the user an opportunity to inject their own code (instrumentation).<h3><a class="anchor" name="Pintools">
Pintools</a></h3>
Conceptually, instrumentation consists of two components:<p>
<ul>
<li>A mechanism that decides where and what code is inserted</li></ul>
<p>
<ul>
<li>The code to execute at insertion points</li></ul>
<p>
These two components are <em>instrumentation</em> and <em>analysis</em> code. Both components live in a single executable, a <em>Pintool</em>. Pintools can be thought of as plugins that can modify the code generation process inside Pin.<p>
The Pintool registers callback routines with Pin that are called from Pin whenever new code needs to be generated. This routine represents the instrumentation component. It inspects the code to be generated, investigates its static properties, and decides if and where to inject calls to analysis code. Those calls can target arbitrary functions inside the Pintool. Pin makes sure that register state is saved and restored as necessary and allow arguments to be passed to the functions.<h3><a class="anchor" name="Observations">
Observations</a></h3>
Since a Pintool works like a plugin, it must run in the same address space as Pin and the executable to be instrumented. Hence the Pintool has access to all of the executable's data. It also shares file descriptors and other process information with the executable.<p>
Pin and the Pintool control a program starting with the very first instruction. For executables compiled with shared libraries this implies that the execution of the dynamic loader and all shared libraries will be visible to the Pintool.<p>
When writing tools, it is more important to tune the analysis code than the instrumentation code. This is because the instrumentation is executed once, but analysis code is called many times.<h3><a class="anchor" name="GRAN">
Instrumentation Granularity</a></h3>
As described above, Pin's instrumentation is "just in time" (JIT). Instrumentation occurs immediately before a code sequence is executed for the first time. We call this mode of operation <em> trace instrumentation </em>.<p>
Trace instrumentation lets the Pintool inspect and instrument an executable one trace at a time. Traces usually begin at the target of a taken branch and end with an unconditional branch, including calls and returns. Pin guarantees that a trace is only entered at the top, but it may contain multiple exits. If a branch joins the middle of a trace, Pin constructs a new trace that begins with the branch target. Pin breaks the trace into basic blocks, <em>BBLs</em>. A BBL is a single entrance, single exit sequence of instructions. Branches to the middle of a bbl begin a new trace and hence a new BBL. It is often possible to insert a single analysis call for a BBL, instead of one analysis call for every instruction. Reducing the number of analysis calls makes instrumentation more efficient. Trace instrumentation utilizes the <a class="el" href="group__TRACE__BASIC__API.html#gb3762f773502ad865216ef941c38799e">TRACE_AddInstrumentFunction</a> API call.<p>
As a convenience for Pintool writers, Pin also offers an <em> instruction instrumentation </em> mode which lets the tool inspect and instrument an executable a single instruction at a time. This is essentially identical to trace instrumentation where the Pintool writer has been freed from the responsibilty of iterating over the instructions inside a trace. As decribed under trace instrumentation, certain BBLs and the instructions inside of them may be generated (and hence instrumented) multiple times. Instruction instrumentation utilizes the <a class="el" href="group__INS__INST__API.html#ga80cd9a7905b82a86b9e31d9bf589dbe">INS_AddInstrumentFunction</a> API call.<p>
Sometimes, however, it can be useful to look at different granularity than a trace. For this purpose Pin offers two additional modes: image and routine instrumentation. These modes are implemented by "caching" instrumentation requests and hence incur a space overhead.<p>
Image instrumentation lets the Pintool inspect and instrument an entire image, IMG, when it is first loaded. A Pintool can walk the sections, SEC, of the image, the routines, RTN, of a section, and the instructions, INS of a routine. Instrumentation can be inserted so that it is executed before or after a routine is executed, or before or after an instruction is executed. Image instrumentation utilizes the <a class="el" href="group__IMG__BASIC__API.html#gb0ad0d50126fd5ddcfee28005c681049">IMG_AddInstrumentFunction</a> API call. Image instrumentation depends on symbol information to determine routine boundaries hence <a class="el" href="group__PIN__CONTROL.html#ga6749650a8dce7151075fcc9345f7bd9">PIN_InitSymbols</a> must be called before <a class="el" href="group__PIN__CONTROL.html#g078bed712e6822f3b42a7b4815ba5c0a">PIN_Init</a>.<p>
Routine instrumentation lets the Pintool inspect and instrument an entire routine before the first time it is called. A Pintool can walk the instructions of a routine. There is not enough information available to break the instructions into BBLs. Instrumentation can be inserted so that it is executed before or after a routine is executed, or before or after an instruction is executed. Routine instrumentation can be more efficient than image instrumentation in space and time when the only a small number of the routines in an image are executed. Routine instrumentation utilizes the <a class="el" href="group__RTN__BASIC__API.html#g8622a6ba858eb8d55df4e006eb165e57">RTN_AddInstrumentFunction</a> API call. Instrumentation of routine exits does not work reliably in the presence of tail calls or when return instructions cannot reliably be detected.<p>
======================================================================================== <h2><a class="anchor" name="EXAMPLES">
Examples</a></h2>
========================================================================================<p>
To illustrate how to write Pintools, we present some simple examples. In the web based version of the manual, you can click on a function in the Pin API to see its documentation.<h3><a class="anchor" name="SimpleCount">
Simple Instruction Count (Instruction Instrumentation)</a></h3>
The example below instruments a program to count the total number of instructions executed. It inserts a call to <code>docount</code> before every instruction. When the program exits, it prints the count to <code>stderr</code>.<p>
Here is how to run it and the output:<p>
<div class="fragment"><pre class="fragment">$ pin -t inscount0.so -- /bin/ls
Makefile          atrace.o     imageload.out  itrace      proccount
Makefile.example  imageload    inscount0      itrace.o    proccount.o
atrace            imageload.o  inscount0.o    itrace.out
Count 422838
$
</pre></div><p>
The example can be found in source/tools/ManualExamples/inscount0.cpp<p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">#include &lt;iostream&gt;</span>
<span class="preprocessor">#include &lt;fstream&gt;</span>
<span class="preprocessor">#include "pin.H"</span>

<span class="comment">// The running count of instructions is kept here</span>
<span class="comment">// make it static to help the compiler optimize docount</span>
<span class="keyword">static</span> UINT64 icount = 0;

<span class="comment">// This function is called before every instruction is executed</span>
VOID docount() { icount++; }
    
<span class="comment">// Pin calls this function every time a new instruction is encountered</span>
VOID Instruction(INS ins, VOID *v)
{
    <span class="comment">// Insert a call to docount before every instruction, no arguments are passed</span>
    <a class="code" href="group__INS__INST__API.html#g82d2ecc73dcd5e2af26fef5bd6ff7190">INS_InsertCall</a>(ins, <a class="code" href="group__INST__ARGS.html#gga46cc1807fc61addd9afe69ee6736a21067f64649fede2cbd09ede8c118c6a0c">IPOINT_BEFORE</a>, (AFUNPTR)docount, <a class="code" href="group__INST__ARGS.html#gg7e2c955c99fa84246bb2bce1525b56812eb9c7482edbcff1aa79eb3329477331">IARG_END</a>);
}

KNOB&lt;string&gt; KnobOutputFile(<a class="code" href="group__KNOB__BASIC.html#gg7cca44bfaca0b4c0f4a6a469ae5b9d67f0336979b5a81ce10e8a3d8f2345d606">KNOB_MODE_WRITEONCE</a>, <span class="stringliteral">"pintool"</span>,
    <span class="stringliteral">"o"</span>, <span class="stringliteral">"inscount.out"</span>, <span class="stringliteral">"specify output file name"</span>);

<span class="comment">// This function is called when the application exits</span>
VOID Fini(INT32 code, VOID *v)
{
    <span class="comment">// Write to a file since cout and cerr maybe closed by the application</span>
    ofstream OutFile;
    OutFile.open(KnobOutputFile.Value().c_str());
    OutFile.setf(ios::showbase);
    OutFile &lt;&lt; <span class="stringliteral">"Count "</span> &lt;&lt; icount &lt;&lt; endl;
    OutFile.close();
}

<span class="comment">// argc, argv are the entire command line, including pin -t &lt;toolname&gt; -- ...</span>
<span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> * argv[])
{
    <span class="comment">// Initialize pin</span>
    <a class="code" href="group__PIN__CONTROL.html#g078bed712e6822f3b42a7b4815ba5c0a">PIN_Init</a>(argc, argv);

    <span class="comment">// Register Instruction to be called to instrument instructions</span>
    <a class="code" href="group__INS__INST__API.html#ga80cd9a7905b82a86b9e31d9bf589dbe">INS_AddInstrumentFunction</a>(Instruction, 0);

    <span class="comment">// Register Fini to be called when the application exits</span>
    <a class="code" href="group__PIN__CONTROL.html#gd5efea3f1ee5611af535e22f35bce145">PIN_AddFiniFunction</a>(Fini, 0);
    
    <span class="comment">// Start the program, never returns</span>
    <a class="code" href="group__PIN__CONTROL.html#gdfaa67ec042ca4a007869b9d2cc080b9">PIN_StartProgram</a>();
    
    <span class="keywordflow">return</span> 0;
}
</pre></div><h3><a class="anchor" name="IAddressTrace">
Instruction Address Trace (Instruction Instrumentation)</a></h3>
In the previous example, we did not pass any arguments to <code>docount</code>, the analysis procedure. In this example, we show how to pass arguments. When calling an analysis procedure, Pin allows you to pass the instruction pointer, current value of registers, effective address of memory operations, constants, etc. For a complete list, see <a class="el" href="group__INST__ARGS.html#g7e2c955c99fa84246bb2bce1525b5681">IARG_TYPE</a>.<p>
With a small change, we can turn the instruction counting example into a Pintool that prints the address of every instruction that is executed. This tool is useful for understanding the control flow of a program for debugging, or in processor design when simulating an instruction cache.<p>
We change the arguments to INS_InsertCall to pass the address of the instruction about to be executed. We replace <code>docount</code> with <code>printip</code>, which prints the instruction address. It writes it output to to the file <code>itrace.out</code>.<p>
This is how to run it and look at the output:<p>
<div class="fragment"><pre class="fragment">$ pin -t itrace.so -- /bin/ls
Makefile          atrace.o     imageload.out  itrace      proccount
Makefile.example  imageload    inscount0      itrace.o    proccount.o
atrace            imageload.o  inscount0.o    itrace.out
$ head itrace.out
0x40001e90
0x40001e91
0x40001ee4
0x40001ee5
0x40001ee7
0x40001ee8
0x40001ee9
0x40001eea
0x40001ef0
0x40001ee0
$
</pre></div><p>
The example can be found in source/tools/ManualExamples/itrace.cpp<p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">#include &lt;stdio.h&gt;</span>
<span class="preprocessor">#include "pin.H"</span>

FILE * trace;

<span class="comment">// This function is called before every instruction is executed</span>
<span class="comment">// and prints the IP</span>
VOID printip(VOID *ip) { fprintf(trace, <span class="stringliteral">"%p\n"</span>, ip); }

<span class="comment">// Pin calls this function every time a new instruction is encountered</span>
VOID Instruction(INS ins, VOID *v)
{
    <span class="comment">// Insert a call to printip before every instruction, and pass it the IP</span>
    <a class="code" href="group__INS__INST__API.html#g82d2ecc73dcd5e2af26fef5bd6ff7190">INS_InsertCall</a>(ins, <a class="code" href="group__INST__ARGS.html#gga46cc1807fc61addd9afe69ee6736a21067f64649fede2cbd09ede8c118c6a0c">IPOINT_BEFORE</a>, (AFUNPTR)printip, <a class="code" href="group__INST__ARGS.html#gg7e2c955c99fa84246bb2bce1525b5681897daee5920e5c9b437f7da52faa758e">IARG_INST_PTR</a>, <a class="code" href="group__INST__ARGS.html#gg7e2c955c99fa84246bb2bce1525b56812eb9c7482edbcff1aa79eb3329477331">IARG_END</a>);
}

<span class="comment">// This function is called when the application exits</span>
VOID Fini(INT32 code, VOID *v)
{
    fprintf(trace, <span class="stringliteral">"#eof\n"</span>);
    fclose(trace);
}

<span class="comment">// argc, argv are the entire command line, including pin -t &lt;toolname&gt; -- ...</span>
<span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> * argv[])
{
    trace = fopen(<span class="stringliteral">"itrace.out"</span>, <span class="stringliteral">"w"</span>);
    
    <span class="comment">// Initialize pin</span>
    <a class="code" href="group__PIN__CONTROL.html#g078bed712e6822f3b42a7b4815ba5c0a">PIN_Init</a>(argc, argv);

    <span class="comment">// Register Instruction to be called to instrument instructions</span>
    <a class="code" href="group__INS__INST__API.html#ga80cd9a7905b82a86b9e31d9bf589dbe">INS_AddInstrumentFunction</a>(Instruction, 0);

    <span class="comment">// Register Fini to be called when the application exits</span>
    <a class="code" href="group__PIN__CONTROL.html#gd5efea3f1ee5611af535e22f35bce145">PIN_AddFiniFunction</a>(Fini, 0);
    
    <span class="comment">// Start the program, never returns</span>
    <a class="code" href="group__PIN__CONTROL.html#gdfaa67ec042ca4a007869b9d2cc080b9">PIN_StartProgram</a>();
    
    <span class="keywordflow">return</span> 0;
}
</pre></div><h3><a class="anchor" name="MAddressTrace">
Memory Reference Trace (Instruction Instrumentation)</a></h3>
The previous example instruments all instructions. Sometimes a tool may only want to instrument a class of instructions, like memory operations or branch instructions. A tool can do this by using the Pin API which includes functions that classify and examine instructions. The basic API is common to all instruction sets and is described <a class="el" href="group__INS__BASIC__API.html">here.</a> In addition, there is an instruction set specific API for the <a class="el" href="group__INS__BASIC__API__IA32.html">IA-32 ISA,</a> and <a class="el" href="group__INS__BASIC__API__IPF.html">IA-64 ISA.</a><p>
In this example, we show how to do more selective instrumentation by examining the instructions. This tool generates a trace of all memory addresses referenced by a program. This is also useful for debugging and for simulating a data cache in a processor.<p>
We only instrument instructions that read or write memory. We also use INS_InsertPredicatedCall instead of INS_InsertCall to avoid generating references to instructions that are predicated and the predicate is false (predication is only relevant for IA-64 ISA).<p>
Since the instrumentation functions are only called once and the analysis functions are called every time an instruction is executed, it is much faster to only instrument the memory operations, as compared to the previous instruction trace example that instruments every instruction.<p>
Here is how to run it and the sample output:<p>
<div class="fragment"><pre class="fragment">$ pin -t pinatrace.so -- /bin/ls
Makefile          atrace.o    imageload.o    inscount0.o  itrace.out
Makefile.example  atrace.out  imageload.out  itrace       proccount
atrace            imageload   inscount0      itrace.o     proccount.o
$ head pinatrace.out 
0x40001ee0: R 0xbfffe798
0x40001efd: W 0xbfffe7d4
0x40001f09: W 0xbfffe7d8
0x40001f20: W 0xbfffe864
0x40001f20: W 0xbfffe868
0x40001f20: W 0xbfffe86c
0x40001f20: W 0xbfffe870
0x40001f20: W 0xbfffe874
0x40001f20: W 0xbfffe878
0x40001f20: W 0xbfffe87c
$
</pre></div><p>
The example can be found in source/tools/ManualExamples/pinatrace.cpp<p>
<div class="fragment"><pre class="fragment"><span class="comment">/*</span>
<span class="comment"> *  This file contains an ISA-portable PIN tool for tracing memory accesses.</span>
<span class="comment"> */</span>

<span class="preprocessor">#include &lt;stdio.h&gt;</span>
<span class="preprocessor">#include "pin.H"</span>


FILE * trace;

<span class="comment">// Print a memory read record</span>
VOID RecordMemRead(VOID * ip, VOID * addr)
{
    fprintf(trace,<span class="stringliteral">"%p: R %p\n"</span>, ip, addr);
}

<span class="comment">// Print a memory write record</span>
VOID RecordMemWrite(VOID * ip, VOID * addr)
{
    fprintf(trace,<span class="stringliteral">"%p: W %p\n"</span>, ip, addr);
}

<span class="comment">// Is called for every instruction and instruments reads and writes</span>
VOID Instruction(INS ins, VOID *v)
{
    <span class="comment">// instruments loads using a predicated call, i.e.</span>
    <span class="comment">// the call happens iff the load will be actually executed</span>
    <span class="comment">// (this does not matter for ia32 but arm and ipf have predicated instructions)</span>
    <span class="keywordflow">if</span> (<a class="code" href="group__INS__BASIC__API__GEN__IA32.html#g52d77b7e3ad272c7aed02875dc9907d5">INS_IsMemoryRead</a>(ins))
    {
        <a class="code" href="group__INS__INST__API.html#g446df8cbefd4950b78cba7c9e7346053">INS_InsertPredicatedCall</a>(
            ins, <a class="code" href="group__INST__ARGS.html#gga46cc1807fc61addd9afe69ee6736a21067f64649fede2cbd09ede8c118c6a0c">IPOINT_BEFORE</a>, (AFUNPTR)RecordMemRead,
            <a class="code" href="group__INST__ARGS.html#gg7e2c955c99fa84246bb2bce1525b5681897daee5920e5c9b437f7da52faa758e">IARG_INST_PTR</a>,
            <a class="code" href="group__INST__ARGS.html#gg7e2c955c99fa84246bb2bce1525b56813cf8e5e03da1a8033539aab405df247a">IARG_MEMORYREAD_EA</a>,
            <a class="code" href="group__INST__ARGS.html#gg7e2c955c99fa84246bb2bce1525b56812eb9c7482edbcff1aa79eb3329477331">IARG_END</a>);
    }

    <span class="comment">// instruments stores using a predicated call, i.e.</span>
    <span class="comment">// the call happens iff the store will be actually executed</span>
    <span class="keywordflow">if</span> (<a class="code" href="group__INS__BASIC__API__GEN__IA32.html#g9b5d5f5c2a4b892fd713810b11639bac">INS_IsMemoryWrite</a>(ins))
    {
        <a class="code" href="group__INS__INST__API.html#g446df8cbefd4950b78cba7c9e7346053">INS_InsertPredicatedCall</a>(
            ins, <a class="code" href="group__INST__ARGS.html#gga46cc1807fc61addd9afe69ee6736a21067f64649fede2cbd09ede8c118c6a0c">IPOINT_BEFORE</a>, (AFUNPTR)RecordMemWrite,
            <a class="code" href="group__INST__ARGS.html#gg7e2c955c99fa84246bb2bce1525b5681897daee5920e5c9b437f7da52faa758e">IARG_INST_PTR</a>,
            <a class="code" href="group__INST__ARGS.html#gg7e2c955c99fa84246bb2bce1525b56818f53184c3630b845c56be31738635dd7">IARG_MEMORYWRITE_EA</a>,
            <a class="code" href="group__INST__ARGS.html#gg7e2c955c99fa84246bb2bce1525b56812eb9c7482edbcff1aa79eb3329477331">IARG_END</a>);
    }
}

VOID Fini(INT32 code, VOID *v)
{
    fprintf(trace, <span class="stringliteral">"#eof\n"</span>);
    fclose(trace);
}


<span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[])
{
    <a class="code" href="group__PIN__CONTROL.html#g078bed712e6822f3b42a7b4815ba5c0a">PIN_Init</a>(argc, argv);

    trace = fopen(<span class="stringliteral">"pinatrace.out"</span>, <span class="stringliteral">"w"</span>);

    <a class="code" href="group__INS__INST__API.html#ga80cd9a7905b82a86b9e31d9bf589dbe">INS_AddInstrumentFunction</a>(Instruction, 0);
    <a class="code" href="group__PIN__CONTROL.html#gd5efea3f1ee5611af535e22f35bce145">PIN_AddFiniFunction</a>(Fini, 0);

    <span class="comment">// Never returns</span>
    <a class="code" href="group__PIN__CONTROL.html#gdfaa67ec042ca4a007869b9d2cc080b9">PIN_StartProgram</a>();
    
    <span class="keywordflow">return</span> 0;
}
</pre></div><h3><a class="anchor" name="ImageLoad">
Detecting the Loading and Unloading of Images (Image Instrumentation)</a></h3>
The example below prints a message to a trace file every time and image is loaded or unloaded. It really abuses the image instrumentation mode as the Pintool neither inspects the image nor adds instrumentation code.<p>
If you invoke it on ls, you would see this output:<p>
<div class="fragment"><pre class="fragment">$ pin -t imageload.so -- /bin/ls
Makefile          atrace.o    imageload.o    inscount0.o  proccount
Makefile.example  atrace.out  imageload.out  itrace       proccount.o
atrace            imageload   inscount0      itrace.o     trace.out
$ cat imageload.out 
Loading /bin/ls
Loading /lib/ld-linux.so.2
Loading /lib/libtermcap.so.2
Loading /lib/i686/libc.so.6
Unloading /bin/ls
Unloading /lib/ld-linux.so.2
Unloading /lib/libtermcap.so.2
Unloading /lib/i686/libc.so.6
$ 
</pre></div><p>
The example can be found in source/tools/ManualExamples/imageload.cpp<p>
<div class="fragment"><pre class="fragment"><span class="comment">//</span>
<span class="comment">// This tool prints a trace of image load and unload events</span>
<span class="comment">//</span>

<span class="preprocessor">#include &lt;stdio.h&gt;</span>
<span class="preprocessor">#include "pin.H"</span>

FILE * trace;

<span class="comment">// Pin calls this function every time a new img is loaded</span>
<span class="comment">// It can instrument the image, but this example does not</span>
<span class="comment">// Note that imgs (including shared libraries) are loaded lazily</span>

VOID ImageLoad(IMG img, VOID *v)
{
    fprintf(trace, <span class="stringliteral">"Loading %s, Image id = %d\n"</span>, <a class="code" href="group__IMG__BASIC__API.html#g9f68164bfac7c031b82549eba91681c3">IMG_Name</a>(img).c_str(), <a class="code" href="group__IMG__BASIC__API.html#g9440e63ee69888e8889a90912f605316">IMG_Id</a>(img));
}

<span class="comment">// Pin calls this function every time a new img is unloaded</span>
<span class="comment">// You can't instrument an image that is about to be unloaded</span>
VOID ImageUnload(IMG img, VOID *v)
{
    fprintf(trace, <span class="stringliteral">"Unloading %s\n"</span>, <a class="code" href="group__IMG__BASIC__API.html#g9f68164bfac7c031b82549eba91681c3">IMG_Name</a>(img).c_str());
}

<span class="comment">// This function is called when the application exits</span>
<span class="comment">// It prints the name and count for each procedure</span>
VOID Fini(INT32 code, VOID *v)
{
    fclose(trace);
}

<span class="comment">// argc, argv are the entire command line, including pin -t &lt;toolname&gt; -- ...</span>
<span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> * argv[])
{
    trace = fopen(<span class="stringliteral">"imageload.out"</span>, <span class="stringliteral">"w"</span>);

    <span class="comment">// Initialize symbol processing</span>
    <a class="code" href="group__PIN__CONTROL.html#ga6749650a8dce7151075fcc9345f7bd9">PIN_InitSymbols</a>();
    
    <span class="comment">// Initialize pin</span>
    <a class="code" href="group__PIN__CONTROL.html#g078bed712e6822f3b42a7b4815ba5c0a">PIN_Init</a>(argc, argv);
    
    <span class="comment">// Register ImageLoad to be called when an image is loaded</span>
    <a class="code" href="group__IMG__BASIC__API.html#gb0ad0d50126fd5ddcfee28005c681049">IMG_AddInstrumentFunction</a>(ImageLoad, 0);

    <span class="comment">// Register ImageUnload to be called when an image is unloaded</span>
    <a class="code" href="group__IMG__BASIC__API.html#gbcbc2007e5a261dcd4893e9bd59ef7aa">IMG_AddUnloadFunction</a>(ImageUnload, 0);

    <span class="comment">// Register Fini to be called when the application exits</span>
    <a class="code" href="group__PIN__CONTROL.html#gd5efea3f1ee5611af535e22f35bce145">PIN_AddFiniFunction</a>(Fini, 0);
    
    <span class="comment">// Start the program, never returns</span>
    <a class="code" href="group__PIN__CONTROL.html#gdfaa67ec042ca4a007869b9d2cc080b9">PIN_StartProgram</a>();
    
    <span class="keywordflow">return</span> 0;
}
</pre></div><h3><a class="anchor" name="inscount1">
More Efficient Instruction Counting (Trace Instrumentation)</a></h3>
The example <a class="el" href="index.html#SimpleCount">Simple Instruction Count (Instruction Instrumentation)</a> computed the number of executed instructions by inserting a call before every instruction. In this example, we make it more efficient by counting the number of instructions in a BBL at instrumentation time, and incrementing the counter once per BBL, instead of once per instruction.<p>
The example can be found in source/tools/ManualExamples/inscount1.cpp<p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">#include &lt;iostream&gt;</span>
<span class="preprocessor">#include &lt;fstream&gt;</span>
<span class="preprocessor">#include "pin.H"</span>

<span class="comment">// The running count of instructions is kept here</span>
<span class="comment">// make it static to help the compiler optimize docount</span>
<span class="keyword">static</span> UINT64 icount = 0;

<span class="comment">// This function is called before every block</span>
VOID docount(INT32 c) { icount += c; }
    
<span class="comment">// Pin calls this function every time a new basic block is encountered</span>
<span class="comment">// It inserts a call to docount</span>
VOID Trace(<a class="code" href="group__TRACE__BASIC__API.html#g72dbbb83ae9ca6278053a75123c920cc">TRACE</a> trace, VOID *v)
{
    <span class="comment">// Visit every basic block  in the trace</span>
    <span class="keywordflow">for</span> (BBL bbl = <a class="code" href="group__TRACE__BASIC__API.html#g1804f26fc605c9344d57be21b392796b">TRACE_BblHead</a>(trace); <a class="code" href="group__BBL__BASIC__API.html#g5aaace888f68ec067f60e3b74c0b9131">BBL_Valid</a>(bbl); bbl = <a class="code" href="group__BBL__BASIC__API.html#g60805b0620b58e2c9ca2add6e16d26ef">BBL_Next</a>(bbl))
    {
        <span class="comment">// Insert a call to docount before every bbl, passing the number of instructions</span>
        <a class="code" href="group__BBL__BASIC__API.html#g5fba2db08badc1f77616c8f41ce31884">BBL_InsertCall</a>(bbl, <a class="code" href="group__INST__ARGS.html#gga46cc1807fc61addd9afe69ee6736a21067f64649fede2cbd09ede8c118c6a0c">IPOINT_BEFORE</a>, (AFUNPTR)docount, <a class="code" href="group__INST__ARGS.html#gg7e2c955c99fa84246bb2bce1525b56814346d7faa1ba877f5bcaf6281473bea3">IARG_UINT32</a>, <a class="code" href="group__BBL__BASIC__API.html#g3d7437048b7fd658b1e4d413c69d9ccb">BBL_NumIns</a>(bbl), <a class="code" href="group__INST__ARGS.html#gg7e2c955c99fa84246bb2bce1525b56812eb9c7482edbcff1aa79eb3329477331">IARG_END</a>);
    }
}

KNOB&lt;string&gt; KnobOutputFile(<a class="code" href="group__KNOB__BASIC.html#gg7cca44bfaca0b4c0f4a6a469ae5b9d67f0336979b5a81ce10e8a3d8f2345d606">KNOB_MODE_WRITEONCE</a>, <span class="stringliteral">"pintool"</span>,
    <span class="stringliteral">"o"</span>, <span class="stringliteral">"inscount.out"</span>, <span class="stringliteral">"specify output file name"</span>);

<span class="comment">// This function is called when the application exits</span>
VOID Fini(INT32 code, VOID *v)
{
    <span class="comment">// Write to a file since cout and cerr maybe closed by the application</span>
    ofstream OutFile;
    OutFile.open(KnobOutputFile.Value().c_str());
    OutFile.setf(ios::showbase);
    OutFile &lt;&lt; <span class="stringliteral">"Count "</span> &lt;&lt; icount &lt;&lt; endl;
    OutFile.close();
}

<span class="comment">// argc, argv are the entire command line, including pin -t &lt;toolname&gt; -- ...</span>
<span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> * argv[])
{
    <span class="comment">// Initialize pin</span>
    <a class="code" href="group__PIN__CONTROL.html#g078bed712e6822f3b42a7b4815ba5c0a">PIN_Init</a>(argc, argv);

    <span class="comment">// Register Instruction to be called to instrument instructions</span>
    <a class="code" href="group__TRACE__BASIC__API.html#gb3762f773502ad865216ef941c38799e">TRACE_AddInstrumentFunction</a>(Trace, 0);

    <span class="comment">// Register Fini to be called when the application exits</span>
    <a class="code" href="group__PIN__CONTROL.html#gd5efea3f1ee5611af535e22f35bce145">PIN_AddFiniFunction</a>(Fini, 0);
    
    <span class="comment">// Start the program, never returns</span>
    <a class="code" href="group__PIN__CONTROL.html#gdfaa67ec042ca4a007869b9d2cc080b9">PIN_StartProgram</a>();
    
    <span class="keywordflow">return</span> 0;
}
</pre></div><h3><a class="anchor" name="ProcInstrCount">
Procedure Instruction Count (Routine Instrumentation)</a></h3>
The example below instruments a program to count the number of times a procedure is called, and the total number of instructions executed in each procedure. When it finishes, it prints a profile to proccount.out<p>
Executing the tool and sample output:<p>
<div class="fragment"><pre class="fragment">$ pin -t proccount.so -- /bin/grep proccount.cpp Makefile
proccount_SOURCES = proccount.cpp
$ head proccount.out
              Procedure           Image            Address        Calls Instructions
                  _fini       libc.so.6         0x40144d00            1           21
__deregister_frame_info       libc.so.6         0x40143f60            2           70
  __register_frame_info       libc.so.6         0x40143df0            2           62
              fde_merge       libc.so.6         0x40143870            0            8
            __init_misc       libc.so.6         0x40115824            1           85
            __getclktck       libc.so.6         0x401157f4            0            2
                 munmap       libc.so.6         0x40112ca0            1            9
                   mmap       libc.so.6         0x40112bb0            1           23
            getpagesize       libc.so.6         0x4010f934            2           26
$
</pre></div><p>
The example can be found in source/tools/ManualExamples/proccount.cpp<p>
<div class="fragment"><pre class="fragment"><span class="comment">//</span>
<span class="comment">// This tool counts the number of a routine is executed and counts</span>
<span class="comment">// the number of instructions executed in a routine</span>
<span class="comment">//</span>

<span class="preprocessor">#include &lt;fstream&gt;</span>
<span class="preprocessor">#include &lt;iomanip&gt;</span>
<span class="preprocessor">#include &lt;string.h&gt;</span>
<span class="preprocessor">#include "pin.H"</span>

<span class="comment">// Holds instruction count for a single procedure</span>
<span class="keyword">typedef</span> <span class="keyword">struct </span>RtnCount
{
    string _name;
    string _image;
    ADDRINT _address;
    RTN _rtn;
    UINT64 _rtnCount;
    UINT64 _icount;
    <span class="keyword">struct </span>RtnCount * _next;
} RTN_COUNT;

<span class="comment">// Linked list of instruction counts for each routine</span>
RTN_COUNT * RtnList = 0;

<span class="comment">// This function is called before every instruction is executed</span>
VOID docount(UINT64 * counter)
{
    (*counter)++;
}
    
<span class="keyword">const</span> <span class="keywordtype">char</span> * StripPath(<span class="keyword">const</span> <span class="keywordtype">char</span> * path)
{
    <span class="keyword">const</span> <span class="keywordtype">char</span> * file = strrchr(path,<span class="charliteral">'/'</span>);
    <span class="keywordflow">if</span> (file)
        <span class="keywordflow">return</span> file+1;
    <span class="keywordflow">else</span>
        <span class="keywordflow">return</span> path;
}

<span class="comment">// Pin calls this function every time a new rtn is executed</span>
VOID Routine(RTN rtn, VOID *v)
{
    
    <span class="comment">// Allocate a counter for this routine</span>
    RTN_COUNT * rc = <span class="keyword">new</span> RTN_COUNT;

    <span class="comment">// The RTN goes away when the image is unloaded, so save it now</span>
    <span class="comment">// because we need it in the fini</span>
    rc-&gt;_name = <a class="code" href="group__RTN__BASIC__API.html#gb274bf5dadf6f1ae3259715ae161ebd1">RTN_Name</a>(rtn);
    rc-&gt;_image = StripPath(<a class="code" href="group__IMG__BASIC__API.html#g9f68164bfac7c031b82549eba91681c3">IMG_Name</a>(<a class="code" href="group__SEC__BASIC__API.html#g12d872ebd06751c73246dc869cf49b91">SEC_Img</a>(<a class="code" href="group__RTN__BASIC__API.html#g9046edfd85722ef2f701282ba7a5c7a2">RTN_Sec</a>(rtn))).c_str());
    rc-&gt;_address = <a class="code" href="group__RTN__BASIC__API.html#gb74b01b5b6feb47a1f52d9f8ea7ea154">RTN_Address</a>(rtn);
    rc-&gt;_icount = 0;
    rc-&gt;_rtnCount = 0;

    <span class="comment">// Add to list of routines</span>
    rc-&gt;_next = RtnList;
    RtnList = rc;
            
    <a class="code" href="group__RTN__BASIC__API.html#g7225aeb74e1fd3f3b554dbbc285653e0">RTN_Open</a>(rtn);
            
    <span class="comment">// Insert a call at the entry point of a routine to increment the call count</span>
    <a class="code" href="group__RTN__BASIC__API.html#g006ef964b9e6e4d8e7880231e216344a">RTN_InsertCall</a>(rtn, <a class="code" href="group__INST__ARGS.html#gga46cc1807fc61addd9afe69ee6736a21067f64649fede2cbd09ede8c118c6a0c">IPOINT_BEFORE</a>, (AFUNPTR)docount, <a class="code" href="group__INST__ARGS.html#gg7e2c955c99fa84246bb2bce1525b56811618560294ef8f249387968f55871e69">IARG_PTR</a>, &amp;(rc-&gt;_rtnCount), <a class="code" href="group__INST__ARGS.html#gg7e2c955c99fa84246bb2bce1525b56812eb9c7482edbcff1aa79eb3329477331">IARG_END</a>);
    
    <span class="comment">// For each instruction of the routine</span>
    <span class="keywordflow">for</span> (INS ins = <a class="code" href="group__RTN__BASIC__API.html#gb49dd96d5d0d0fdcf38c922585c6ba06">RTN_InsHead</a>(rtn); <a class="code" href="group__INS__BASIC__API__GEN__IA32.html#g98b61a0ca7456dce466a5f773656e310">INS_Valid</a>(ins); ins = <a class="code" href="group__INS__BASIC__API__GEN__IA32.html#g2711640bba1359feb3385a0c7b42ff4b">INS_Next</a>(ins))
    {
        <span class="comment">// Insert a call to docount to increment the instruction counter for this rtn</span>
        <a class="code" href="group__INS__INST__API.html#g82d2ecc73dcd5e2af26fef5bd6ff7190">INS_InsertCall</a>(ins, <a class="code" href="group__INST__ARGS.html#gga46cc1807fc61addd9afe69ee6736a21067f64649fede2cbd09ede8c118c6a0c">IPOINT_BEFORE</a>, (AFUNPTR)docount, <a class="code" href="group__INST__ARGS.html#gg7e2c955c99fa84246bb2bce1525b56811618560294ef8f249387968f55871e69">IARG_PTR</a>, &amp;(rc-&gt;_icount), <a class="code" href="group__INST__ARGS.html#gg7e2c955c99fa84246bb2bce1525b56812eb9c7482edbcff1aa79eb3329477331">IARG_END</a>);
    }

    
    <a class="code" href="group__RTN__BASIC__API.html#g1e79031f51f9dbdc1726cc46b01870c3">RTN_Close</a>(rtn);
}

<span class="comment">// This function is called when the application exits</span>
<span class="comment">// It prints the name and count for each procedure</span>
VOID Fini(INT32 code, VOID *v)
{
    ofstream count(<span class="stringliteral">"proccount.out"</span>);

    count &lt;&lt; setw(23) &lt;&lt; <span class="stringliteral">"Procedure"</span> &lt;&lt; <span class="stringliteral">" "</span>
          &lt;&lt; setw(15) &lt;&lt; <span class="stringliteral">"Image"</span> &lt;&lt; <span class="stringliteral">" "</span>
          &lt;&lt; setw(18) &lt;&lt; <span class="stringliteral">"Address"</span> &lt;&lt; <span class="stringliteral">" "</span>
          &lt;&lt; setw(12) &lt;&lt; <span class="stringliteral">"Calls"</span> &lt;&lt; <span class="stringliteral">" "</span>
          &lt;&lt; setw(12) &lt;&lt; <span class="stringliteral">"Instructions"</span> &lt;&lt; endl;

    <span class="keywordflow">for</span> (RTN_COUNT * rc = RtnList; rc; rc = rc-&gt;_next)
    {
        <span class="keywordflow">if</span> (rc-&gt;_icount &gt; 0)
            count &lt;&lt; setw(23) &lt;&lt; rc-&gt;_name &lt;&lt; <span class="stringliteral">" "</span>
                  &lt;&lt; setw(15) &lt;&lt; rc-&gt;_image &lt;&lt; <span class="stringliteral">" "</span>
                  &lt;&lt; setw(18) &lt;&lt; hex &lt;&lt; rc-&gt;_address &lt;&lt; dec &lt;&lt;<span class="stringliteral">" "</span>
                  &lt;&lt; setw(12) &lt;&lt; rc-&gt;_rtnCount &lt;&lt; <span class="stringliteral">" "</span>
                  &lt;&lt; setw(12) &lt;&lt; rc-&gt;_icount &lt;&lt; endl;
    }

}

<span class="comment">// argc, argv are the entire command line, including pin -t &lt;toolname&gt; -- ...</span>
<span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> * argv[])
{
    <span class="comment">// Initialize symbol table code, needed for rtn instrumentation</span>
    <a class="code" href="group__PIN__CONTROL.html#ga6749650a8dce7151075fcc9345f7bd9">PIN_InitSymbols</a>();

    <span class="comment">// Initialize pin</span>
    <a class="code" href="group__PIN__CONTROL.html#g078bed712e6822f3b42a7b4815ba5c0a">PIN_Init</a>(argc, argv);

    <span class="comment">// Register Routine to be called to instrument rtn</span>
    <a class="code" href="group__RTN__BASIC__API.html#g8622a6ba858eb8d55df4e006eb165e57">RTN_AddInstrumentFunction</a>(Routine, 0);

    <span class="comment">// Register Fini to be called when the application exits</span>
    <a class="code" href="group__PIN__CONTROL.html#gd5efea3f1ee5611af535e22f35bce145">PIN_AddFiniFunction</a>(Fini, 0);
    
    <span class="comment">// Start the program, never returns</span>
    <a class="code" href="group__PIN__CONTROL.html#gdfaa67ec042ca4a007869b9d2cc080b9">PIN_StartProgram</a>();
    
    <span class="keywordflow">return</span> 0;
}
</pre></div><h3><a class="anchor" name="StaticInstructionCounts">
Image Instrumentation</a></h3>
It is also possible to use pin to examine binaries without instrumenting them. This is useful when you need to know static properties of an image. The sample tool below counts the number of instructions in an image, but does not insert any instrumentation.<p>
The example can be found in source/tools/ManualExamples/staticcount.cpp<p>
<div class="fragment"><pre class="fragment"><span class="comment">//</span>
<span class="comment">// This tool prints a trace of image load and unload events</span>
<span class="comment">//</span>

<span class="preprocessor">#include &lt;stdio.h&gt;</span>
<span class="preprocessor">#include "pin.H"</span>


<span class="comment">// Pin calls this function every time a new img is loaded</span>
<span class="comment">// It can instrument the image, but this example merely</span>
<span class="comment">// counts the number of static instructions in the image</span>

VOID ImageLoad(IMG img, VOID *v)
{
    UINT32 count = 0;
    
    <span class="keywordflow">for</span> (SEC sec = <a class="code" href="group__IMG__BASIC__API.html#gc217d3b81c96828a0ee9a7574d3ac05f">IMG_SecHead</a>(img); <a class="code" href="group__SEC__BASIC__API.html#g1b12fe810ea34835d192449f8d41e226">SEC_Valid</a>(sec); sec = <a class="code" href="group__SEC__BASIC__API.html#g594dcea6346920b05dc979e379959a77">SEC_Next</a>(sec))
    { 
        <span class="keywordflow">for</span> (RTN rtn = <a class="code" href="group__SEC__BASIC__API.html#g3015a2dd44717006bca05e459b344b42">SEC_RtnHead</a>(sec); <a class="code" href="group__RTN__BASIC__API.html#g2883b22d046e8c6c5ac303465dfa4ed6">RTN_Valid</a>(rtn); rtn = <a class="code" href="group__RTN__BASIC__API.html#gf21d0d3fd6851e83e42827f09c03a4e7">RTN_Next</a>(rtn))
        {
            <span class="comment">// Prepare for processing of RTN, an  RTN is not broken up into BBLs,</span>
            <span class="comment">// it is merely a sequence of INSs </span>
            <a class="code" href="group__RTN__BASIC__API.html#g7225aeb74e1fd3f3b554dbbc285653e0">RTN_Open</a>(rtn);
            
            <span class="keywordflow">for</span> (INS ins = <a class="code" href="group__RTN__BASIC__API.html#gb49dd96d5d0d0fdcf38c922585c6ba06">RTN_InsHead</a>(rtn); <a class="code" href="group__INS__BASIC__API__GEN__IA32.html#g98b61a0ca7456dce466a5f773656e310">INS_Valid</a>(ins); ins = <a class="code" href="group__INS__BASIC__API__GEN__IA32.html#g2711640bba1359feb3385a0c7b42ff4b">INS_Next</a>(ins))
            {
                count++;
            }

            <span class="comment">// to preserve space, release data associated with RTN after we have processed it</span>
            <a class="code" href="group__RTN__BASIC__API.html#g1e79031f51f9dbdc1726cc46b01870c3">RTN_Close</a>(rtn);
        }
    }
    fprintf(stderr, <span class="stringliteral">"Image %s has  %d instructions\n"</span>, <a class="code" href="group__IMG__BASIC__API.html#g9f68164bfac7c031b82549eba91681c3">IMG_Name</a>(img).c_str(), count);
}

<span class="comment">// argc, argv are the entire command line, including pin -t &lt;toolname&gt; -- ...</span>
<span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> * argv[])
{
    <span class="comment">// prepare for image instrumentation mode</span>
    <a class="code" href="group__PIN__CONTROL.html#ga6749650a8dce7151075fcc9345f7bd9">PIN_InitSymbols</a>();

    <span class="comment">// Initialize pin</span>
    <a class="code" href="group__PIN__CONTROL.html#g078bed712e6822f3b42a7b4815ba5c0a">PIN_Init</a>(argc, argv);

    <span class="comment">// Register ImageLoad to be called when an image is loaded</span>
    <a class="code" href="group__IMG__BASIC__API.html#gb0ad0d50126fd5ddcfee28005c681049">IMG_AddInstrumentFunction</a>(ImageLoad, 0);

    <span class="comment">// Start the program, never returns</span>
    <a class="code" href="group__PIN__CONTROL.html#gdfaa67ec042ca4a007869b9d2cc080b9">PIN_StartProgram</a>();
    
    <span class="keywordflow">return</span> 0;
}
</pre></div><h3><a class="anchor" name="DetachPin">
Detaching Pin from the Application</a></h3>
Pin can relinquish control of application any time when invoked via <a class="el" href="group__PIN__CONTROL.html#g0f3537980bb5ab3b0411a83426a32370">PIN_Detach</a>. Control is returned to the original uninstrumented code and the application runs at native speed. Thereafter no instrumented code is ever executed.<p>
The example can be found in source/tools/ManualExamples/detach.cpp<p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">#include &lt;stdio.h&gt;</span>
<span class="preprocessor">#include "pin.H"</span>
<span class="preprocessor">#include &lt;iostream&gt;</span>

<span class="comment">// This tool shows how to detach Pin from an </span>
<span class="comment">// application that is under Pin's control.</span>

UINT64 icount = 0;

<span class="preprocessor">#define N 10000</span>
<span class="preprocessor"></span>VOID docount() 
{
    icount++;

    <span class="comment">// Release control of application if 10000 </span>
    <span class="comment">// instructions have been executed</span>
    <span class="keywordflow">if</span> ((icount % N) == 0) 
    {
        <a class="code" href="group__PIN__CONTROL.html#g0f3537980bb5ab3b0411a83426a32370">PIN_Detach</a>();
    }
}
 
VOID Instruction(INS ins, VOID *v)
{
    <a class="code" href="group__INS__INST__API.html#g82d2ecc73dcd5e2af26fef5bd6ff7190">INS_InsertCall</a>(ins, <a class="code" href="group__INST__ARGS.html#gga46cc1807fc61addd9afe69ee6736a21067f64649fede2cbd09ede8c118c6a0c">IPOINT_BEFORE</a>, (AFUNPTR)docount, <a class="code" href="group__INST__ARGS.html#gg7e2c955c99fa84246bb2bce1525b56812eb9c7482edbcff1aa79eb3329477331">IARG_END</a>);
}

VOID ByeWorld(VOID *v)
{
    std::cerr &lt;&lt; endl &lt;&lt; <span class="stringliteral">"Detached at icount = "</span> &lt;&lt; N &lt;&lt; endl;
}

<span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> * argv[])
{
    <a class="code" href="group__PIN__CONTROL.html#g078bed712e6822f3b42a7b4815ba5c0a">PIN_Init</a>(argc, argv);

    <span class="comment">// Callback function to invoke for every </span>
    <span class="comment">// execution of an instruction</span>
    <a class="code" href="group__INS__INST__API.html#ga80cd9a7905b82a86b9e31d9bf589dbe">INS_AddInstrumentFunction</a>(Instruction, 0);
    
    <span class="comment">// Callback functions to invoke before</span>
    <span class="comment">// Pin releases control of the application</span>
    <a class="code" href="group__PIN__CONTROL.html#g451060f5e998243df750ac16720cadcf">PIN_AddDetachFunction</a>(ByeWorld, 0);
    
    <span class="comment">// Never returns</span>
    <a class="code" href="group__PIN__CONTROL.html#gdfaa67ec042ca4a007869b9d2cc080b9">PIN_StartProgram</a>();
    
    <span class="keywordflow">return</span> 0;
}
</pre></div><h3><a class="anchor" name="ReplaceSigProbed">
Replacing a Routine in Probe Mode</a></h3>
Probe mode is a method of using Pin to insert probes at the start of specified routines. A probe is a jump instruction that is placed at the start of the specified routine. The probe redirects the flow of control to the replacement function. Before the probe is inserted, the first few instructions of the specified routine are relocated. It is not uncommon for the replacement function to call the replaced routine. Pin provides the relocated address to facilate this. See the example below.<p>
In probe mode, the application and the replacement routine are run natively. This improves performance, but it puts more responsibility on the tool writer. Probes can only be placed on RTN boundaries.<p>
Many of the PIN APIs that are available in JIT mode are not applicable in Probe mode. In particular, the Pin thread APIs are not supported in Probe mode, because Pin has no information about the threads when the application is run natively. For more information, check the RTN API documentation.<p>
The tool writer must guarantee that there is not jump target where the probe is placed. A probe is five bytes long on IA-32 architecture, seven bytes long on Intel(R) 64 architecture, and one bundle on IA-64 architecture.<p>
Also, it is the tool writer's responsibility to ensure that no thread is currently executing the code where a probe is inserted. Tool writers are encouraged to insert probes when an image is loaded to avoid this problem. Pin will automatically remove the probes when an image is unloaded.<p>
When using probes, Pin must be started with the <a class="el" href="group__PIN__CONTROL.html#g7de96e728655962e8ecb4cfe49bd6c2c">PIN_StartProgramProbed()</a> API.<p>
Note that on newer Linux OSes, additional libraries must be installed to use probe mode. See <a class="el" href="index.html#LIBRARIES">Libraries for Linux</a> for further information.<p>
The example can be found in source/tools/ManualExamples/replacesigprobed.cpp. To build this test, execute: <div class="fragment"><pre class="fragment">$ make replacesigprobed.test
</pre></div><p>
<div class="fragment"><pre class="fragment"><span class="comment">//  Replace an original function with a custom function defined in the tool using</span>
<span class="comment">//  probes.  The replacement function has a different signature from that of the </span>
<span class="comment">//  original replaced function.</span>

<span class="preprocessor">#include "pin.H"</span>
<span class="preprocessor">#include &lt;iostream&gt;</span>
<span class="keyword">using namespace </span>std;

<span class="keyword">typedef</span> VOID * ( *FP_MALLOC )( size_t );

<span class="comment">// This is the replacement routine.</span>
<span class="comment">//</span>
VOID * NewMalloc( FP_MALLOC orgFuncptr, UINT32 arg0, ADDRINT returnIp )
{
    <span class="comment">// Normally one would do something more interesting with this data.</span>
    <span class="comment">//</span>
    cout &lt;&lt; <span class="stringliteral">"NewMalloc ("</span>
         &lt;&lt; hex &lt;&lt; ADDRINT ( orgFuncptr ) &lt;&lt; <span class="stringliteral">", "</span> 
         &lt;&lt; dec &lt;&lt; arg0 &lt;&lt; <span class="stringliteral">", "</span> 
         &lt;&lt; hex &lt;&lt; returnIp &lt;&lt; <span class="stringliteral">")"</span>
         &lt;&lt; endl &lt;&lt; flush;

    <span class="comment">// Call the relocated entry point of the original (replaced) routine.</span>
    <span class="comment">//</span>
    VOID * v = orgFuncptr( arg0 );

    <span class="keywordflow">return</span> v;
}


<span class="comment">// Pin calls this function every time a new img is loaded.</span>
<span class="comment">// It is best to do probe replacement when the image is loaded,</span>
<span class="comment">// because only one thread knows about the image at this time.</span>
<span class="comment">//</span>
VOID ImageLoad( IMG img, VOID *v )
{
    <span class="comment">// See if malloc() is present in the image.  If so, replace it.</span>
    <span class="comment">//</span>
    RTN rtn = <a class="code" href="group__RTN__BASIC__API.html#g926d67b40afab106e86ccbb33565c889">RTN_FindByName</a>( img, <span class="stringliteral">"malloc"</span> );
    
    <span class="keywordflow">if</span> (<a class="code" href="group__RTN__BASIC__API.html#g2883b22d046e8c6c5ac303465dfa4ed6">RTN_Valid</a>(rtn))
    {
        cout &lt;&lt; <span class="stringliteral">"Replacing malloc in "</span> &lt;&lt; <a class="code" href="group__IMG__BASIC__API.html#g9f68164bfac7c031b82549eba91681c3">IMG_Name</a>(img) &lt;&lt; endl;
        
        <span class="comment">// Define a function prototype that describes the application routine</span>
        <span class="comment">// that will be replaced.</span>
        <span class="comment">//</span>
        <a class="code" href="group__PROTO__API.html#gaa40d7e36e9ad7a07ee68adb5b312377">PROTO</a> proto_malloc = <a class="code" href="group__PROTO__API.html#g49300accd53f8e574af0b706ee553625">PROTO_Allocate</a>( <a class="code" href="group__PROTO__API.html#gae8aea17c700049aa39c32c370874f47">PIN_PARG</a>(<span class="keywordtype">void</span> *), CALLINGSTD_DEFAULT,
                                             <span class="stringliteral">"malloc"</span>, <a class="code" href="group__PROTO__API.html#gae8aea17c700049aa39c32c370874f47">PIN_PARG</a>(<span class="keywordtype">int</span>), <a class="code" href="group__PROTO__API.html#gb8a98de8d0939ae762c9b890097a350b">PIN_PARG_END</a>() );
        
        <span class="comment">// Replace the application routine with the replacement function.</span>
        <span class="comment">// Additional arguments have been added to the replacement routine.</span>
        <span class="comment">//</span>
        <a class="code" href="group__RTN__BASIC__API.html#g71867842a83631b4400913e89d8527e2">RTN_ReplaceSignatureProbed</a>(rtn, AFUNPTR(NewMalloc),
                                   <a class="code" href="group__INST__ARGS.html#gg7e2c955c99fa84246bb2bce1525b5681f007683926859b1cfd7c10c66a3555e2">IARG_PROTOTYPE</a>, proto_malloc,
                                   <a class="code" href="group__INST__ARGS.html#gg7e2c955c99fa84246bb2bce1525b56812a8d49dccc99d1dfaeb26d8b3e583505">IARG_ORIG_FUNCPTR</a>,
                                   <a class="code" href="group__INST__ARGS.html#gg7e2c955c99fa84246bb2bce1525b5681c82efb4d44af4401e73fc01b7ac1c3c3">IARG_FUNCARG_ENTRYPOINT_VALUE</a>, 0,
                                   <a class="code" href="group__INST__ARGS.html#gg7e2c955c99fa84246bb2bce1525b5681a9f63b1e494a1c86d00e4836f845c0c5">IARG_RETURN_IP</a>,
                                   <a class="code" href="group__INST__ARGS.html#gg7e2c955c99fa84246bb2bce1525b56812eb9c7482edbcff1aa79eb3329477331">IARG_END</a>);

        <span class="comment">// Free the function prototype.</span>
        <span class="comment">//</span>
        <a class="code" href="group__PROTO__API.html#g0affd7dbe19f86b3b3ffb260540d37e4">PROTO_Free</a>( proto_malloc );
    }
}


<span class="comment">// Initialize and start Pin in Probe mode. </span>
<span class="comment">//</span>
<span class="keywordtype">int</span> main( INT32 argc, CHAR *argv[] )
{
    <span class="comment">// Initialize symbol processing</span>
    <span class="comment">//</span>
    <a class="code" href="group__PIN__CONTROL.html#ga6749650a8dce7151075fcc9345f7bd9">PIN_InitSymbols</a>();
    
    <span class="comment">// Initialize pin</span>
    <span class="comment">//</span>
    <a class="code" href="group__PIN__CONTROL.html#g078bed712e6822f3b42a7b4815ba5c0a">PIN_Init</a>( argc, argv );
    
    <span class="comment">// Register ImageLoad to be called when an image is loaded</span>
    <span class="comment">//</span>
    <a class="code" href="group__IMG__BASIC__API.html#gb0ad0d50126fd5ddcfee28005c681049">IMG_AddInstrumentFunction</a>( ImageLoad, 0 );
    
    <span class="comment">// Start the program in probe mode, never returns</span>
    <span class="comment">//</span>
    <a class="code" href="group__PIN__CONTROL.html#g7de96e728655962e8ecb4cfe49bd6c2c">PIN_StartProgramProbed</a>();
    
    <span class="keywordflow">return</span> 0;
}

</pre></div><p>
======================================================================================== <h2><a class="anchor" name="CALLBACK">
Call Backs</a></h2>
========================================================================================<p>
The examples in the previous section have introduced a number of ways to register call back functions via the Pin API:<p>
<ul>
<li><a class="el" href="group__INS__INST__API.html#ga80cd9a7905b82a86b9e31d9bf589dbe">INS_AddInstrumentFunction</a> (INSCALLBACK fun, VOID *val)</li><li><a class="el" href="group__TRACE__BASIC__API.html#gb3762f773502ad865216ef941c38799e">TRACE_AddInstrumentFunction</a> (TRACECALLBACK fun, VOID *val)</li><li><a class="el" href="group__RTN__BASIC__API.html#g8622a6ba858eb8d55df4e006eb165e57">RTN_AddInstrumentFunction</a> (RTNCALLBACK fun, VOID *val)</li><li><a class="el" href="group__IMG__BASIC__API.html#gb0ad0d50126fd5ddcfee28005c681049">IMG_AddInstrumentFunction</a> (IMGCALLBACK fun, VOID *val)</li><li><a class="el" href="group__PIN__CONTROL.html#gd5efea3f1ee5611af535e22f35bce145">PIN_AddFiniFunction</a> (FINICALLBACK fun, VOID *val)</li><li><a class="el" href="group__PIN__CONTROL.html#g451060f5e998243df750ac16720cadcf">PIN_AddDetachFunction</a> (DETACHCALLBACK fun, VOID *val)</li></ul>
<p>
The extra parameter <code>val</code> (shared by all the registration functions) will be passed to <code>fun</code> as its second argument whenever it is "called back". This is a standard mechanism used in GUI programming with call backs.<p>
If this feature is not needed, it is safe to pass 0 for <code>val</code> when registering a call back. The expected use of <code>val</code> is to pass a pointer to an instance of a class. Since <code>val</code> is a generic pointer, <code>fun</code> must cast it back to an object before dereferencing the pointer.<p>
======================================================================================== <h2><a class="anchor" name="EX">
Applying a Pintool to an Application</a></h2>
========================================================================================<p>
An application and a tool are invoked as follows:<p>
<div class="fragment"><pre class="fragment">pin [pin-option]... -t [toolname] [tool-options]... -- [application] [application-option]..
</pre></div><p>
These are a few of the Pin options are currently available. See <a class="el" href="group__KNOBS.html">Command Line Switches</a> for the complete list. <ul>
<li>
-t <em>toolname</em>: specifies the Pintool to use. If you are running a 32-bit application in an IA-32 architecture, or a 64-bit application on an IA-64 architecture, only -t &lt;toolname&gt; is needed. If you are running an application on an Intel(R) 64 architecture, where all of the components in the chain are either 32-bit or 64-bit, but not both, only -t &lt;toolname&gt; is needed. See <a class="el" href="index.html#MIXED-MODE">Instrumenting Applications on Intel(R) 64 Architectures.</a> </li>
<li>
-t64 <em>toolname</em>: Specify tool binary for Intel(R) 64 architecture. See <a class="el" href="index.html#MIXED-MODE">Instrumenting Applications on Intel(R) 64 Architectures.</a> </li>
<li>
-p32 <em>toolname</em>: Specify Pin binary for IA-32 architecture. See <a class="el" href="index.html#MIXED-MODE">Instrumenting Applications on Intel(R) 64 Architectures.</a> </li>
<li>
-p64 <em>toolname</em>: Specify Pin binary for Intel(R) 64 architecture. See <a class="el" href="index.html#MIXED-MODE">Instrumenting Applications on Intel(R) 64 Architectures.</a> </li>
<li>
-pause_tool n: is a useful Pin-option which prints out the process id and pauses Pin for n seconds to permit attaching with gdb. See <a class="el" href="index.html#DEBUGGING">Tips for Debugging a Pintool</a>. </li>
<li>
-follow_execv: Execute with Pin all processes spawned by execv class system calls. </li>
<li>
-injection <em>mode</em>: Where <em>mode</em> is one of dynamic, self, child, parent. <em>UNIX-only</em> See <a class="el" href="index.html#INJECTION">Injection</a>.<p>
</li>
</ul>
<p>
The tool-options follow immediately after the tool specification and depend on the tool used.<p>
Everything following the <code>--</code> is the command line for the application.<p>
For example, to apply the itrace example (<a class="el" href="index.html#IAddressTrace">Instruction Address Trace (Instruction Instrumentation)</a>) to a run of the "ls" program:<p>
<div class="fragment"><pre class="fragment">pin -t itrace.so -- /bin/ls
</pre></div><p>
To get a listing of the available command line options for Pin:<p>
<div class="fragment"><pre class="fragment">pin -help
</pre></div><p>
To get a listing of the available command line options for the itrace example:<p>
<div class="fragment"><pre class="fragment">pin -t itrace.so -help -- /bin/ls
</pre></div><p>
Note that in the last case <code>/bin/ls</code> is necessary on the command line but will not be executed.<h3><a class="anchor" name="MIXED-MODE">
Instrumenting Applications on Intel(R) 64 Architectures.</a></h3>
The Pin kit for IA-32 and Intel(R) 64 architectures is a combined kit. Both a 32-bit version and a 64-bit version of Pin are present in the kit. This allows Pin to instrument complex applications on Intel(R) 64 architectures which may have 32-bit and 64-bit components.<p>
An application and a tool are invoked in "mixed-mode" as follows:<p>
<div class="fragment"><pre class="fragment">pin [pin-option]... -t64 &lt;64-bit toolname&gt; -t &lt;32-bit toolname&gt; [tool-options]...
-- &lt;application&gt; [application-option]..
</pre></div><p>
See source/tools/CrossIa32Intel64/makefile for further information.<p>
The file "pin" is a script that expects the Pin binary "pinbin" to be in the architecture-specific "bin" subdirectory (i.e. intel64/bin). The "pin" script distinguishes the 32-bit version of the Pin binary from the 64-bit version of the Pin binary by using the -p32/-p64 switches, respectively. Today, the 32-bit version of the Pin binary is invoked, and the path of the 64-bit version of Pin is passed as an argument using the -p64 switch. However, one could change this to invoke the 64-bit version of the Pin binary, and pass the 32-bit version of the Pin binary as an argument using the -p32 switch.<p>
See <a class="el" href="index.html#LIBRARIES">Libraries for Linux</a> for more information about the environment variables that are set up in the "pin" script.<h3><a class="anchor" name="INJECTION">
Injection</a></h3>
The -injection switch is UNIX-only and controls the way pin is injected into the application process. The default, dynamic, is recommended for all users. It uses parent injection unless it is unsupported (Linux 2.4 kernels). Child injection creates the application process as a child of the pin process so you will see both a pin process and the application process running. In parent injection, the pin process exits after injecting the application and is less likely to cause a problem. Using parent injection on an unsupported platform may lead to nondeterministic errors.<p>
IMPORTANT: The description about invoking assumes that the application is a program binary (and not a shell script). If your application is invoked indirectly (from a shell script or using 'exec') then you need to change the actual invocation of the program binary by prefixing it with pin/pintool options. Here's one way of doing that:<p>
<div class="fragment"><pre class="fragment"><span class="preprocessor"> # Track down the actual application binary, say it is 'application_binary'.</span>
<span class="preprocessor"></span> % mv application_binary application_binary.real

<span class="preprocessor"> # Write a shell script named 'application_binary' with the following contents.</span>
<span class="preprocessor"></span><span class="preprocessor"> # (change 'itrace' to your desired tool)</span>
<span class="preprocessor"></span>
<span class="preprocessor"> #!/bin/sh</span>
<span class="preprocessor"> pin -t itrace.so -- application_binary.real $*</span>
</pre></div><p>
After you do this, whenever 'application_binary' is invoked indirectly (from some shell script or using 'exec'), the real binary will get invoked with the right pin/pintool options.<p>
======================================================================================== <h2><a class="anchor" name="DEBUGGING">
Tips for Debugging a Pintool</a></h2>
========================================================================================<p>
When running an application under the control of Pin and a Pintool there are two different programs residing in the address space. The application, and the Pin instrumentation engine together with your Pintool. The pintool is normally a shared object loaded by Pin. This section describes how to use gdb to find bugs in a Pintool. You cannot run Pin directly from gdb since Pin uses the debugging API to start the application. Instead, you must invoke Pin from the command line with the -pause_tool switch, and use gdb to attach to the Pin process from another window. The -pause_tool n switch makes Pin print out the process identifier (pid) and pause for n seconds.<h3><a class="anchor" name="XXX">
Using gdb on Linux:</a></h3>
Pin searches for the tool in an internal search algorithm. Therefore in many cases gdb is unable to load the debug info for the tool. There are several options to help gdb find the debug info.<p>
Option 1 is to use full path to the tool when running pin.<p>
Option 2 is to tell gdb to load the debugging information of the tool. Pin prompts with the exact gdb command to be used in this case.<p>
To check that gdb loaded the debugging info to the tool use the command "info sharedlibrary" and you should see that gdb has read the symbols for your tool (as in the example below).<p>
<div class="fragment"><pre class="fragment">(gdb) info sharedlibrary
From        To          Syms Read   Shared Object Library
0x001b3ea0  0x001b4d80  Yes         /lib/libdl.so.2
0x003b3820  0x00431d74  Yes         /usr/intel/pkgs/gcc/4.2.0/lib/libstdc++.so.6
0x0084f4f0  0x00866f8c  Yes         /lib/i686/libm.so.6
0x00df8760  0x00dffcc4  Yes         /usr/intel/pkgs/gcc/4.2.0/lib/libgcc_s.so.1
0x00e5fa00  0x00f60398  Yes         /lib/i686/libc.so.6
0x40001c50  0x4001367f  Yes         /lib/ld-linux.so.2
0x008977f0  0x00af7784  Yes         ./dcache.so
</pre></div><p>
For example, if your tool is called opcodemix and the application is /bin/ls, you can use gdb as described below. The following example is for the Intel(R) 64 Linux platform. Substitute "ia32" or "ia64" for the IA-32 architecture or IA-64 architecture.<p>
Change directory to the directory where your tool resides, and start gdb with pin, but do not use the run command:<p>
<div class="fragment"><pre class="fragment">$ /usr/bin/gdb ../../../intel64/bin/pinbin
GNU gdb Red Hat Linux (6.3.0.0-1.132.EL4rh)
Copyright 2004 Free Software Foundation, Inc.
GDB is free software, covered by the GNU General Public License, and you are
welcome to change it and/or distribute copies of it under certain conditions.
Type "show copying" to see the conditions.
There is absolutely no warranty for GDB.  Type "show warranty" for details.
This GDB was configured as "x86_64-redhat-linux-gnu"...Using host libthread_db library "/lib64/tls/libthread_db.so.1"
(gdb)
</pre></div><p>
In another window, start your application with the -pause_tool switch:<p>
<div class="fragment"><pre class="fragment">$ ../../../intel64/bin/pinbin -pause_tool 10 -t obj-intel64/opcodemix.so -- /bin/ls
Pausing to attach to pid 28769
To load the tool's debug info to gdb use:
   add-symbol-file .../source/tools/SimpleExamples/obj-intel64/opcodemix.so 0x2a959e9830
</pre></div><p>
Then go back to gdb and attach to the process:<p>
<div class="fragment"><pre class="fragment">(gdb) attach 28769
Attaching to program: .../intel64/bin/pinbin, process 28769
0x000000314b38f7a2 in ?? ()
(gdb)
</pre></div><p>
Now, you should tell gdb to load the Pintool debugging information, by copying the debugging message we got when invoking pin with the -pause_tool switch..<p>
<div class="fragment"><pre class="fragment">(gdb) add-symbol-file .../source/tools/SimpleExamples/obj-intel64/opcodemix.so 0x2a959e9830
add symbol table from file <span class="stringliteral">".../source/tools/SimpleExamples/obj-intel64/opcodemix.so"</span> at
        .text_addr = 0x2a959e9830
        (y or n) y
        Reading symbols from .../source/tools/SimpleExamples/obj-intel64/opcodemix.so...done.
(gdb)
</pre></div><p>
Now, instead of using the gdb run command, you use the <code>cont</code> command to continue execution. You can also set breakpoints as normal:<p>
<div class="fragment"><pre class="fragment">(gdb) b opcodemix.cpp:447
Breakpoint 1 at 0x2a959ecf60: file opcodemix.cpp, line 447.
(gdb) cont
Continuing.

Breakpoint 1, main (argc=7, argv=0x3ff00f12f8) at opcodemix.cpp:447
447     <span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, CHAR *argv[])
(gdb) 
</pre></div><p>
If the program does not exit, then you should detach so gdb will release control:<p>
<div class="fragment"><pre class="fragment">(gdb) detach
Detaching from program: .../intel64/bin/pinbin, process 28769
(gdb) 
</pre></div><p>
If you recompile your program and then use the run command, gdb will notice that the binary has been changed and reread the debug information from the file. This does not always happen automatically when using attach. In this case you must use the "add-symbol-file" command again to make gdb reread the debug information.<p>
======================================================================================== <h2><a class="anchor" name="LOGGING">
Logging Messages from a Pintool</a></h2>
========================================================================================<p>
Pin provides a mechanism to write messages from a Pintool to a logfile. To use this capability, call the LOG() API with your message. The default filename is pintool.log, and it is created in the currently working directory. Use the -logfile switch after the tool name to change the path and file name of the log file.<p>
<div class="fragment"><pre class="fragment">LOG( <span class="stringliteral">"Replacing function in "</span> + <a class="code" href="group__IMG__BASIC__API.html#g9f68164bfac7c031b82549eba91681c3">IMG_Name</a>(img) + <span class="stringliteral">"\n"</span> );
LOG( <span class="stringliteral">"Address = "</span> + hexstr( <a class="code" href="group__RTN__BASIC__API.html#gb74b01b5b6feb47a1f52d9f8ea7ea154">RTN_Address</a>(rtn)) + <span class="stringliteral">"\n"</span> );
LOG( <span class="stringliteral">"Image ID = "</span> + decstr( <a class="code" href="group__IMG__BASIC__API.html#g9440e63ee69888e8889a90912f605316">IMG_Id</a>(img) ) + <span class="stringliteral">"\n"</span> );
</pre></div><p>
======================================================================================== <h2><a class="anchor" name="PERFORMANCE">
Performance Consideration When Writing  a Pintool</a></h2>
========================================================================================<p>
The way a Pintool is written can have great impact on the performace of the tool, i.e. how much it slows down the applications it is instrumenting. This section demonstrates some techniques that can be used to improve tool performance. Let's start with an example. The following piece of code is derived from the source/tools/SimpleExamples/edgcnt.cpp:<p>
The instrumentation component of the tool is show below<p>
<div class="fragment"><pre class="fragment">VOID Instruction(INS ins, <span class="keywordtype">void</span> *v)
{
      ...

      <span class="keywordflow">if</span> ( [ins is a branch or a call instruction] ) 
      {
          
        
        <a class="code" href="group__INS__INST__API.html#g82d2ecc73dcd5e2af26fef5bd6ff7190">INS_InsertCall</a>(ins, <a class="code" href="group__INST__ARGS.html#gga46cc1807fc61addd9afe69ee6736a21067f64649fede2cbd09ede8c118c6a0c">IPOINT_BEFORE</a>, (AFUNPTR) docount2,
                       <a class="code" href="group__INST__ARGS.html#gg7e2c955c99fa84246bb2bce1525b5681897daee5920e5c9b437f7da52faa758e">IARG_INST_PTR</a>,
                       <a class="code" href="group__INST__ARGS.html#gg7e2c955c99fa84246bb2bce1525b5681883669f246ea24704e3a30a8ec25354b">IARG_BRANCH_TARGET_ADDR</a>,
                       <a class="code" href="group__INST__ARGS.html#gg7e2c955c99fa84246bb2bce1525b568177719c0c3ef7fa35672eefe4209d8361">IARG_BRANCH_TAKEN</a>,
                       <a class="code" href="group__INST__ARGS.html#gg7e2c955c99fa84246bb2bce1525b56812eb9c7482edbcff1aa79eb3329477331">IARG_END</a>);
      }

      ...
}
</pre></div><p>
The analysis component looks like this: <div class="fragment"><pre class="fragment">VOID docount2( ADDRINT src, ADDRINT dst, INT32 taken )
{
    <span class="keywordflow">if</span>(!taken) <span class="keywordflow">return</span>;
    COUNTER *pedg = Lookup( src,dst );
    pedg-&gt;_count++;
} 
</pre></div><p>
The purpose of the tool is to count how often each controlflow changing edge in the control flowgraph is traversed. The tool considers both calls and branches but for brevity we will not mention branches in our description. The tool works as follows: The instrumentation component instruments each branch with a call to docount2. As parameters we pass in the origin and the target of the branch and whether the branch was taken or not. Branch origin and target represent of the source and destination of the controlflow edges. If a branch is not taken the controlflow does not change and hence the analysis routine returns right away. If the branch is taken we use the src and dst parameters to look up the counter associated with this edge (Lookup will create a new one if this edge has not been seen before) and increment the counter. Note, that the tool could have been simplified somewhat by using IPOINT_TAKEN_BRANCH option with <a class="el" href="group__INS__INST__API.html#g82d2ecc73dcd5e2af26fef5bd6ff7190">INS_InsertCall()</a>.<h3><a class="anchor" name="shifting_computation">
Shifting Computation for Analysis to Instrumentation Code</a></h3>
About every 5th instruction executed in a typical application is a branch. Lookup will called whenever these instruction are executed, causing significant application slowdown. To improve the situation we note that the instrumentation code is typically called only once for every instruction, while the analysis code is called everytime the instruction is executed. If we can somehow shift computation from the analysis code to the instrumentation code we will improve the overall performance. Our example tools offer multiple such opportunites which will explore in turn. The first observation is that for most branches we can find out inside of Instruction() what the branch target will be . For those branches we can call Lookup inside of Instruction() rather than in docount2(), for indirect branches which are relatively rare we still have to use our original approach. All this is reflected in the folling code. We add a second "lighter" analsysis function, docount. While the original docount2() remains unchanged:<p>
<div class="fragment"><pre class="fragment">VOID docount( COUNTER *pedg, INT32 taken )
{
    <span class="keywordflow">if</span>( !taken ) <span class="keywordflow">return</span>;
    pedg-&gt;_count++;
}
</pre></div><p>
And the instrumentation will be somewhat more complex:<p>
<div class="fragment"><pre class="fragment">VOID Instruction(INS ins, <span class="keywordtype">void</span> *v)
{
      ...

    <span class="keywordflow">if</span> (<a class="code" href="group__INS__BASIC__API__GEN__IA32.html#g64333f9a28052aabc341a7a0d3c16aec">INS_IsDirectBranchOrCall</a>(ins))
    {
        COUNTER *pedg = Lookup( <a class="code" href="group__INS__BASIC__API__GEN__IA32.html#gd3b5f975c84b126531b38930b94b5544">INS_Address</a>(ins),  <a class="code" href="group__INS__BASIC__API__GEN__IA32.html#ga52df2852835cd0938a5f2c0e81aaecd">INS_DirectBranchOrCallTargetAddress</a>(ins) );

        <a class="code" href="group__INS__INST__API.html#g82d2ecc73dcd5e2af26fef5bd6ff7190">INS_InsertCall</a>(ins, <a class="code" href="group__INST__ARGS.html#gga46cc1807fc61addd9afe69ee6736a21067f64649fede2cbd09ede8c118c6a0c">IPOINT_BEFORE</a>, (AFUNPTR) docount, 
                       <a class="code" href="group__INST__ARGS.html#gg7e2c955c99fa84246bb2bce1525b56811bf9954bfcc59b75c446dd2edd2875f0">IARG_ADDRINT</a>, pedg, 
                       <a class="code" href="group__INST__ARGS.html#gg7e2c955c99fa84246bb2bce1525b568177719c0c3ef7fa35672eefe4209d8361">IARG_BRANCH_TAKEN</a>, 
                       <a class="code" href="group__INST__ARGS.html#gg7e2c955c99fa84246bb2bce1525b56812eb9c7482edbcff1aa79eb3329477331">IARG_END</a>);           
    }
    <span class="keywordflow">else</span>
    {
        <a class="code" href="group__INS__INST__API.html#g82d2ecc73dcd5e2af26fef5bd6ff7190">INS_InsertCall</a>(ins, <a class="code" href="group__INST__ARGS.html#gga46cc1807fc61addd9afe69ee6736a21067f64649fede2cbd09ede8c118c6a0c">IPOINT_BEFORE</a>, (AFUNPTR) docount2,
                       <a class="code" href="group__INST__ARGS.html#gg7e2c955c99fa84246bb2bce1525b5681897daee5920e5c9b437f7da52faa758e">IARG_INST_PTR</a>,
                       <a class="code" href="group__INST__ARGS.html#gg7e2c955c99fa84246bb2bce1525b5681883669f246ea24704e3a30a8ec25354b">IARG_BRANCH_TARGET_ADDR</a>,
                       <a class="code" href="group__INST__ARGS.html#gg7e2c955c99fa84246bb2bce1525b568177719c0c3ef7fa35672eefe4209d8361">IARG_BRANCH_TAKEN</a>,
                       <a class="code" href="group__INST__ARGS.html#gg7e2c955c99fa84246bb2bce1525b56812eb9c7482edbcff1aa79eb3329477331">IARG_END</a>);
    }

      ...
}
</pre></div><h3><a class="anchor" name="shifting_computation">
Shifting Computation for Analysis to Instrumentation Code</a></h3>
The code for docount() is very compact which besides the obvious performance advantages may also cause it to be inlined by pin thereby avoiding the overhead of a call. The heuristics for when a analysis routine is inlined by pin are subject to change. But small routines without any controlflow (single basic block) are almost guaranteed to be inlined. Unfortunately, docount() does have (albeit limited) controlflow. Observing that the parameter, taken, will be zero or one we can eliminate the remaining controlflow as follows:<p>
<div class="fragment"><pre class="fragment">VOID docount( COUNTER *pedg, INT32 taken )
{
    pedg-&gt;_count += taken;
}
</pre></div><p>
There is now no question whether docount() will be inlined or not.<h3><a class="anchor" name="let_pin_decide">
Letting Pin Decide Where to Instrument</a></h3>
At times we do not care about the exact point where calls to analysis code are being inserted as long as it is within a given basic block. In this case we can let Pin make the decission where to insert. This has the advantage that Pin can select am insertion point that requires minimal register saving and restoring. The following code from ManualExamples/inscount2.cpp shows how this is done for the instruction count example using IPOINT_ANYWHERE with <a class="el" href="group__BBL__BASIC__API.html#g5fba2db08badc1f77616c8f41ce31884">BBL_InsertCall()</a>.<p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">#include &lt;iostream&gt;</span>
<span class="preprocessor">#include &lt;fstream&gt;</span>
<span class="preprocessor">#include "pin.H"</span>

<span class="comment">// The running count of instructions is kept here</span>
<span class="comment">// make it static to help the compiler optimize docount</span>
<span class="keyword">static</span> UINT64 icount = 0;

<span class="comment">// This function is called before every block</span>
<span class="comment">// Use the fast linkage for calls</span>
VOID <a class="code" href="group__INST__ARGS.html#gf3202cd2f4be9bf9d4fa7a035ece147b">PIN_FAST_ANALYSIS_CALL</a> docount(ADDRINT c) { icount += c; }
    
<span class="comment">// Pin calls this function every time a new basic block is encountered</span>
<span class="comment">// It inserts a call to docount</span>
VOID Trace(<a class="code" href="group__TRACE__BASIC__API.html#g72dbbb83ae9ca6278053a75123c920cc">TRACE</a> trace, VOID *v)
{
    <span class="comment">// Visit every basic block  in the trace</span>
    <span class="keywordflow">for</span> (BBL bbl = <a class="code" href="group__TRACE__BASIC__API.html#g1804f26fc605c9344d57be21b392796b">TRACE_BblHead</a>(trace); <a class="code" href="group__BBL__BASIC__API.html#g5aaace888f68ec067f60e3b74c0b9131">BBL_Valid</a>(bbl); bbl = <a class="code" href="group__BBL__BASIC__API.html#g60805b0620b58e2c9ca2add6e16d26ef">BBL_Next</a>(bbl))
    {
        <span class="comment">// Insert a call to docount for every bbl, passing the number of instructions.</span>
        <span class="comment">// IPOINT_ANYWHERE allows Pin to schedule the call anywhere in the bbl to obtain best performance.</span>
        <span class="comment">// Use a fast linkage for the call.</span>
        <a class="code" href="group__BBL__BASIC__API.html#g5fba2db08badc1f77616c8f41ce31884">BBL_InsertCall</a>(bbl, <a class="code" href="group__INST__ARGS.html#gga46cc1807fc61addd9afe69ee6736a2198931604835e0f9ad1cd29cc1bc1f384">IPOINT_ANYWHERE</a>, AFUNPTR(docount), <a class="code" href="group__INST__ARGS.html#gg7e2c955c99fa84246bb2bce1525b5681c51073d5f62b8800cb3285ede6f9077e">IARG_FAST_ANALYSIS_CALL</a>, <a class="code" href="group__INST__ARGS.html#gg7e2c955c99fa84246bb2bce1525b56814346d7faa1ba877f5bcaf6281473bea3">IARG_UINT32</a>, <a class="code" href="group__BBL__BASIC__API.html#g3d7437048b7fd658b1e4d413c69d9ccb">BBL_NumIns</a>(bbl), <a class="code" href="group__INST__ARGS.html#gg7e2c955c99fa84246bb2bce1525b56812eb9c7482edbcff1aa79eb3329477331">IARG_END</a>);
    }
}

KNOB&lt;string&gt; KnobOutputFile(<a class="code" href="group__KNOB__BASIC.html#gg7cca44bfaca0b4c0f4a6a469ae5b9d67f0336979b5a81ce10e8a3d8f2345d606">KNOB_MODE_WRITEONCE</a>, <span class="stringliteral">"pintool"</span>,
    <span class="stringliteral">"o"</span>, <span class="stringliteral">"inscount.out"</span>, <span class="stringliteral">"specify output file name"</span>);

<span class="comment">// This function is called when the application exits</span>
VOID Fini(INT32 code, VOID *v)
{
    <span class="comment">// Write to a file since cout and cerr maybe closed by the application</span>
    ofstream OutFile;
    OutFile.open(KnobOutputFile.Value().c_str());
    OutFile.setf(ios::showbase);
    OutFile &lt;&lt; <span class="stringliteral">"Count "</span> &lt;&lt; icount &lt;&lt; endl;
    OutFile.close();
}

<span class="comment">// argc, argv are the entire command line, including pin -t &lt;toolname&gt; -- ...</span>
<span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> * argv[])
{
    <span class="comment">// Initialize pin</span>
    <a class="code" href="group__PIN__CONTROL.html#g078bed712e6822f3b42a7b4815ba5c0a">PIN_Init</a>(argc, argv);

    <span class="comment">// Register Instruction to be called to instrument instructions</span>
    <a class="code" href="group__TRACE__BASIC__API.html#gb3762f773502ad865216ef941c38799e">TRACE_AddInstrumentFunction</a>(Trace, 0);

    <span class="comment">// Register Fini to be called when the application exits</span>
    <a class="code" href="group__PIN__CONTROL.html#gd5efea3f1ee5611af535e22f35bce145">PIN_AddFiniFunction</a>(Fini, 0);
    
    <span class="comment">// Start the program, never returns</span>
    <a class="code" href="group__PIN__CONTROL.html#gdfaa67ec042ca4a007869b9d2cc080b9">PIN_StartProgram</a>();
    
    <span class="keywordflow">return</span> 0;
}
</pre></div><h3><a class="anchor" name="fast_linkage">
Using Fast Call Linkages</a></h3>
For very small analysis functions, the overhead to call the function can be comparable to the work done in the function. Some compilers offer optimized call linkages that eliminate some of the overhead. For example, gcc for the IA-32 architecture has a regparm attribute for passing arguments in registers. Pin supports a limited number of alternate linkages. To use it, you must annotate the declaration of the analysis function with <a class="el" href="group__INST__ARGS.html#gf3202cd2f4be9bf9d4fa7a035ece147b">PIN_FAST_ANALYSIS_CALL</a>. The InsertCall function must pass <a class="el" href="group__INST__ARGS.html#gg7e2c955c99fa84246bb2bce1525b5681c51073d5f62b8800cb3285ede6f9077e">IARG_FAST_ANALYSIS_CALL</a>. If you change one without changing the other, the arguments will not be passed correctly. See the inscount2.cpp example in the previous section for a sample use. For large analysis functions, the benefit may not be significant, but it is unlikely that PIN_FAST_ANALYSIS_CALL would ever cause a slowdown.<p>
Another call linkage optimization is to eliminate the frame pointer. We recommend using -fomit-frame-pointer to compile tools with gcc. See the gcc documentation for an explanation of what it does. The standard Pintool makefiles include -fomit-frame-pointer. Like PIN_FAST_ANALYSIS_CALL, the benefit is largest for small analysis functions. Debuggers rely on frame pointers to display stack traces, so eliminate this option when trying to debug a PinTool. If you are using a standard PinTool makefile, you can do this by overriding the definition of OPT on the command line with<p>
<div class="fragment"><pre class="fragment">make OPT=-O0
</pre></div><h3><a class="anchor" name="partial_inline">
Rewriting Conditional Analysis Code to Help Pin Inline</a></h3>
Pin improves instrumentation performance by automatically inlining analysis routines that have no control-flow changes. Of course, many analysis routines do have control-flow changes. One particularly common case is that an analysis routine has a single "if-then" test, where a small amount of analysis code plus the test is always executed but the "then" part is executed only once a while. To inline this common case, Pin provides a set of conditional instrumentation APIs for the tool writer to rewrite their analysis routines into a form that does not have control-flow changes. The following example from source/tools/ManualExamples/isampling.cpp illustrates how such rewriting can be done:<p>
<div class="fragment"><pre class="fragment"><span class="comment">/*</span>
<span class="comment"> *  This file contains a Pintool for sampling the IPs of instruction executed.</span>
<span class="comment"> *  It serves as an example of a more efficient way to write analysis routines</span>
<span class="comment"> *  that include conditional tests.</span>
<span class="comment"> *  Currently, it works on IA-32 and Intel(R) 64 architectures.</span>
<span class="comment"> */</span>

<span class="preprocessor">#include &lt;stdio.h&gt;</span>
<span class="preprocessor">#include &lt;stdlib.h&gt;</span>
<span class="preprocessor">#include "pin.H"</span>

FILE * trace;

<span class="keyword">const</span> INT32 N = 100000;
<span class="keyword">const</span> INT32 M =  50000;

INT32 icount = N;

<span class="comment">/*</span>
<span class="comment"> *  IP-sampling could be done in a single analysis routine like:</span>
<span class="comment"> *</span>
<span class="comment"> *        VOID IpSample(VOID *ip)</span>
<span class="comment"> *        {</span>
<span class="comment"> *            --icount;</span>
<span class="comment"> *            if (icount == 0)</span>
<span class="comment"> *            {</span>
<span class="comment"> *               fprintf(trace, "%p\n", ip);</span>
<span class="comment"> *               icount = N + rand() % M;</span>
<span class="comment"> *            }</span>
<span class="comment"> *        }</span>
<span class="comment"> *</span>
<span class="comment"> *  However, we break IpSample() into two analysis routines,</span>
<span class="comment"> *  CountDown() and PrintIp(), to facilitate Pin inlining CountDown()</span>
<span class="comment"> *  (which is the much more frequently executed one than PrintIp()).</span>
<span class="comment"> */</span>

ADDRINT CountDown()
{
    --icount;
    <span class="keywordflow">return</span> (icount==0);
}


<span class="comment">// The IP of the current instruction will be printed and</span>
<span class="comment">// the icount will be reset to a random number between N and N+M.</span>
VOID PrintIp(VOID *ip)
{
    fprintf(trace, <span class="stringliteral">"%p\n"</span>, ip);
    
    <span class="comment">// Prepare for next period</span>
    icount = N + rand() % M; <span class="comment">// random number from N to N+M</span>
}


<span class="comment">// Pin calls this function every time a new instruction is encountered</span>
VOID Instruction(INS ins, VOID *v)
{
    <span class="comment">// CountDown() is called for every instruction executed</span>
    <a class="code" href="group__INS__INST__API.html#g4182ef22ec1351bb0ee998b023263349">INS_InsertIfCall</a>(ins, <a class="code" href="group__INST__ARGS.html#gga46cc1807fc61addd9afe69ee6736a21067f64649fede2cbd09ede8c118c6a0c">IPOINT_BEFORE</a>, (AFUNPTR)CountDown, <a class="code" href="group__INST__ARGS.html#gg7e2c955c99fa84246bb2bce1525b56812eb9c7482edbcff1aa79eb3329477331">IARG_END</a>);
    
    <span class="comment">// PrintIp() is called only when the last CountDown() returns a non-zero value.</span>
    <a class="code" href="group__INS__INST__API.html#g0063b9298e92dfc50569d033fcaa4bee">INS_InsertThenCall</a>(ins, <a class="code" href="group__INST__ARGS.html#gga46cc1807fc61addd9afe69ee6736a21067f64649fede2cbd09ede8c118c6a0c">IPOINT_BEFORE</a>, (AFUNPTR)PrintIp, <a class="code" href="group__INST__ARGS.html#gg7e2c955c99fa84246bb2bce1525b5681897daee5920e5c9b437f7da52faa758e">IARG_INST_PTR</a>, <a class="code" href="group__INST__ARGS.html#gg7e2c955c99fa84246bb2bce1525b56812eb9c7482edbcff1aa79eb3329477331">IARG_END</a>);
    
}

<span class="comment">// This function is called when the application exits</span>
VOID Fini(INT32 code, VOID *v)
{
    fprintf(trace, <span class="stringliteral">"#eof\n"</span>);
    fclose(trace);
}

<span class="comment">// argc, argv are the entire command line, including pin -t &lt;toolname&gt; -- ...</span>
<span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> * argv[])
{
    trace = fopen(<span class="stringliteral">"isampling.out"</span>, <span class="stringliteral">"w"</span>);
    
    <span class="comment">// Initialize pin</span>
    <a class="code" href="group__PIN__CONTROL.html#g078bed712e6822f3b42a7b4815ba5c0a">PIN_Init</a>(argc, argv);

    <span class="comment">// Register Instruction to be called to instrument instructions</span>
    <a class="code" href="group__INS__INST__API.html#ga80cd9a7905b82a86b9e31d9bf589dbe">INS_AddInstrumentFunction</a>(Instruction, 0);

    <span class="comment">// Register Fini to be called when the application exits</span>
    <a class="code" href="group__PIN__CONTROL.html#gd5efea3f1ee5611af535e22f35bce145">PIN_AddFiniFunction</a>(Fini, 0);
    
    <span class="comment">// Start the program, never returns</span>
    <a class="code" href="group__PIN__CONTROL.html#gdfaa67ec042ca4a007869b9d2cc080b9">PIN_StartProgram</a>();
    
    <span class="keywordflow">return</span> 0;
}
</pre></div><p>
In the above example, the original analysis routine IpSample() has a conditional control-flow change. It is rewritten into two analysis routines: CountDown() and PrintIp(). CountDown() is the simpler one of the two, which doesn't have control-flow change. It also performs the original conditional test and returns the test result. We use the conditional instrumentaton APIs <a class="el" href="group__INS__INST__API.html#g4182ef22ec1351bb0ee998b023263349">INS_InsertIfCall()</a> and <a class="el" href="group__INS__INST__API.html#g0063b9298e92dfc50569d033fcaa4bee">INS_InsertThenCall()</a> to tell Pin that tbe analysis routine specified by an <a class="el" href="group__INS__INST__API.html#g0063b9298e92dfc50569d033fcaa4bee">INS_InsertThenCall()</a> (i.e. PrintIp() in this example) is executed only if the result of the analysis routine specified by the previous <a class="el" href="group__INS__INST__API.html#g4182ef22ec1351bb0ee998b023263349">INS_InsertIfCall()</a> (i.e. CountDown() in this example) is non-zero. Now CountDown(), the common case, can be inlined by Pin, and only once a while does Pin need to execute PrintIp(), the non-inlined case.<p>
======================================================================================== <h2><a class="anchor" name="INSTALLATION">
Installing Pin</a></h2>
========================================================================================<p>
To install a kit, unpack a kit and change to the directory:<p>
<div class="fragment"><pre class="fragment">$ tar zxf pin-2.4-20148-gcc.3.4.6-ia32_intel64-linux.tar.gz
$ cd pin-2.4-20148-gcc.3.4.6-ia32_intel64-linux
</pre></div><p>
Build and test the examples from the manual<p>
<div class="fragment"><pre class="fragment">$ cd source/tools/ManualExamples/
$ make test
/usr/bin/g++ -c -Wall -Werror -Wno-unknown-pragmas -g -O3 -fomit-frame-pointer
         -DBIGARRAY_MULTIPLIER=1 -DUSING_XED -g -fno-strict-aliasing -I../Include
         -I../InstLib -I../../../extras/xed2-intel64/include -I../../../source/include
         -I../../../source/include/gen -DTARGET_IA32E -DHOST_IA32E -fPIC -DTARGET_LINUX
         -o obj-intel64/inscount0.o inscount0.cpp
/usr/bin/g++ -g -shared -Wl,-Bsymbolic -Wl,--version-script=../../../source/include/pintool.ver
         -L../Lib/ -L../ExtLib/ -L../../../extras/xed2-intel64/lib -L../../../intel64/lib
         -L../../../intel64/lib-ext  -o obj-intel64/inscount0.so obj-intel64/inscount0.o
         -L../Lib/ -L../ExtLib/ -L../../../extras/xed2-intel64/lib -L../../../intel64/lib
         -L../../../intel64/lib-ext -lpin  -lxed -ldwarf -lelf -ldl  -gtouch inscount0.tested
touch inscount0.failed
touch obj-intel64/inscount0.so.makefile.copy; rm obj-intel64/inscount0.so.makefile.copy
../../../pin -slow_asserts    -t obj-intel64/inscount0.so -- /bin/cp makefile obj-intel64/inscount0.so.makefile.copy
cmp makefile obj-intel64/inscount0.so.makefile.copy
rm obj-intel64/inscount0.so.makefile.copy; rm inscount0.failed

&lt;etc.&gt;
</pre></div><p>
Run one of the sample tools from the installed directory. Use "obj-ia32" for the IA-32 architecture, "obj-intel64" for the Intel(R) 64 architecture, and "obj-ia64" for the IA-64 architecture.<p>
<div class="fragment"><pre class="fragment">$ ../Bin/pin -t obj-intel64/pinatrace.so -- /bin/ls
_insprofiler.cpp  atrace.out   inscount0.o      itrace.cpp  proccount
atrace          imageload.cpp  inscount1.cpp    itrace.o    proccount.cpp
atrace.cpp      inscount0      insprofiler.cpp  itrace.out  proccount.o
atrace.o        inscount0.cpp  itrace           makefile    proccount.out
$ head pinatrace.out 
0x40001ee0: R 0xbfffe1e8
0x40001efd: W 0xbfffe224
0x40001f09: W 0xbfffe228
0x40001f20: W 0xbfffe2b4
0x40001f20: W 0xbfffe2b8
0x40001f20: W 0xbfffe2bc
0x40001f20: W 0xbfffe2c0
0x40001f20: W 0xbfffe2c4
0x40001f20: W 0xbfffe2c8
0x40001f20: W 0xbfffe2cc
$ 
</pre></div><p>
To write your own tool, copy one of the example directories and edit the makefile to add your tool. The sample tool MyPinTool is recommended. This tool allows you to build either inside or outside the Pin environment.<p>
======================================================================================== <h2><a class="anchor" name="EXTRA_WINDOWS">
Additional information for Windows</a></h2>
========================================================================================<h3><a class="anchor" name="building">
Building tools for VC8 kit in Visual Studio 2005*</a></h3>
In order to use pin kit VC8, you must have Visual Studio 2005* installed on your computer.<p>
An example of the Visual Studio 2005* project that builds pin tool in the Visual Studio IDE can be found in the MyPinTool directory.<p>
Enter this directory and open MyPinTool.vcproj project or MyPinTool.sln solution. To build the tool, press "Build Solution" (F7).<p>
To run an application, instrumented by MyPinTool, press "Start Without Debugging" (Ctrl-F5). You can select another application and change tool's switches in the "MyPinTool Properties-&gt;Debugging" page.<p>
You can use MyPinTool as a template for your own project. Please, look carefully at the compilation and linking switches in the MyPinTool property pages. Mandatory switches can be found in the ms.flags file in the kit's source directory. Following are some of them:<p>
<div class="fragment"><pre class="fragment">  /MT            link to static CRT library. Using 
                 CRT DLL could cause conflict with
                 the application using the same DLL.
  /EHs- /EHa-    disable exception handling in the tool,
                 otherwise it could interfere in the
                 application's exception handling.
  /wd4530        turn off the warning about not having 
                 /EHsc turned on, while using STL.
  /EXPORT:main   main function of the tool has to be exported
  /ENTRY:....    tool DLL should be initialized by pin.lib
  /NODEFAULTLIB  do not link and use any system library except
                 for those listed explicitly to avoid conflicts
                 with an application using the same library
  /BASE:....     helps to avoid layout conflicts with DLLs linked
                 to the application
</pre></div><h3><a class="anchor" name="nmake">
Building tools for VC8 kit using Microsoft* NMAKE* utility</a></h3>
Open Command Prompt window and enter the kit's root directory or one of its subdirectories. Check to see that the directory contains the Nmakefile file. Notice, some of the subdirectories do not contain Nmakefile because they are not intended to demonstrate pin features in Windows. Type one of the following commands:<p>
To build all tool examples: <div class="fragment"><pre class="fragment">     nmake
</pre></div><p>
To run all tests: <div class="fragment"><pre class="fragment">     nmake test
</pre></div><p>
To delete build targets and results of tests: <div class="fragment"><pre class="fragment">    nmake clean
</pre></div><p>
To build specific tool example: <div class="fragment"><pre class="fragment">     cd SimpleExamples
      ..\nmake opcodemix.dll
</pre></div><p>
To test specific tool: <div class="fragment"><pre class="fragment">     cd SimpleExamples
     ..\nmake opcodemix.test
</pre></div><p>
Notice, "nmake" in the above commands is the nmake.bat file from the kit's root directory. To invoke nmake.exe directly, you must specify the makefile as the input file:<p>
<div class="fragment"><pre class="fragment">     nmake.exe /F Nmakefile
</pre></div><p>
Otherwise, instead of Nmakefile, nmake.exe will find the GNU "makefile" file that resides in the same directory.<h3><a class="anchor" name="multi">
Constructing PinTools from multiple DLLs on Windows</a></h3>
A Pin tool can be composed from multiple DLLs:<ul>
<li>"main DLL", which is specified in the Pin command line after "-t" switch</li><li>a number of "secondary DLLs", linked to the "main DLL" statically or loaded dynamically.</li></ul>
<p>
When considering this configuration, take into account that multi-DLL Pin tool may increase memory fragmentation and cause layout conflicts with application images. If there is no compelling reasons for using multiple DLLs, build your tool as a single DLL to reduce the risk of memory conflicts.<p>
Limitations and instructions:<ul>
<li>Don't use any Pin API in "secondary DLLs". Only "main DLL" can use Pin API!</li><li>Use one of the following methods to load "secondary DLLs":<ul>
<li>statically link "secondary DLLs" to the "main DLL"</li><li>dynamically load "secondary DLLs" in the main() function of "main DLL". Do not load DLLs in instrumentation/analysis callbacks - it is unsafe!</li></ul>
</li><li>If necessary, unload "secondary DLLs" in the main() function of "main DLL". Do not unload DLLs in instrumentation/analysis callbacks - it is unsafe!</li><li>Build each DLL with the recommended flags (see <a class="el" href="index.html#building">Building tools for VC8 kit in Visual Studio 2005*</a>).</li><li>Remove /EXPORT:main link flag for "secondary DLLs".</li><li>Specify different base address for each DLL (/BASE link flag). When choosing base addresses, try to minimize memory fragmentation and layout conflicts.</li></ul>
<p>
======================================================================================== <h2><a class="anchor" name="WINLIBRARIES">
Libraries for Windows</a></h2>
========================================================================================<p>
Pin on Windows uses dbghelp.dll by Microsoft* to provide symbolic information. This DLL is not distributed with the kit. In order to get support for symbolic information in Pin, you have to download the "Debugging Tools For Windows*" package, version 6.8.4.0 from <a href="http://www.microsoft.com/whdc/devtools/debugging/default.mspx.">http://www.microsoft.com/whdc/devtools/debugging/default.mspx.</a> Use "Debugging Tools For Windows* 32-bit Version" for IA-32 architectures and "Debugging Tools For Windows* - Native X64" for Intel(R) 64 architectures. Distribution of the debugging tools is provided in .msi format which must be installed to extract a single file. Copy dbghelp.dll from the package into "ia32\bin" or "intel64\bin" directory of the Pin kit. This directory should already contain pin.exe and pinvm.dll files.<p>
======================================================================================== <h2><a class="anchor" name="LIBRARIES">
Libraries for Linux</a></h2>
========================================================================================<h3><a class="anchor" name="LIBRARIES_INTRO">
Introduction</a></h3>
The Linux version of pin requires the shared objects from glibc:<p>
<div class="fragment"><pre class="fragment">libc
libm
libdl
ld-linux*
</pre></div><p>
and g++ libraries:<p>
<div class="fragment"><pre class="fragment">libstdc++
libgcc_s
</pre></div><p>
If your system does not have the runtime libraries required for gcc3.4 or later(/usr/lib/libstdc++.so.6), then we recommend that you install them. Installing the compiler will install the runtime libraries. If that is not possible, then we provide the libraries and a method to use them from a local directory. If you want to use a probe based tool, then you cannot use the default glibc that comes with recent linux distributions. We provide the libraries and a method to use them from a local directory.<h3><a class="anchor" name="LIBRARIES_NO_PROBE">
How to Install Libraries If You Do Not Use Probe-mode</a></h3>
If your system does not have libstdc++.so.6 installed and you are not using probe mode, then download pin-jit-runtime.tar.gz and untar it into the top level directory of the pin kit.<p>
<div class="fragment"><pre class="fragment">tproj&gt; tar zxf pin-2.4-20350-gcc.3.4.6-ia32_intel64-linux.tar.gz
tproj&gt; cd pin-2.4-20350-gcc.3.4.6-ia32_intel64-linux

tproj/pin-2.4-20350-gcc.3.4.6-ia32_intel64-linux&gt; tar zxf ../pin-jit-runtime.tar.gz
</pre></div><p>
The file "pin" is a script that will set up the environment to find the libraries you installed from pin-jit-runtime.tar.gz. These directories will be searched first, followed by directories that are on the LD_LIBRARY_PATH.<p>
If you need to change the directory structure or copy pin to a different directory, then you must understand the following. The file "pin" is a script that expects the binary "pinbin" to be in the architecture-specific "bin" subdirectory (i.e. ia32/bin). The script expects the libraries to be found in the architecture-specific "runtime" subdirectory (i.e. ia32/runtime). If you need a different directory structure, you can edit the pin script. The pin binary does not make assumptions about the directory structure.<p>
We try to keep the libraries in pin-jit-runtime.tar.gz up to date so you can use the latest version of gcc. If you have problems with undefined symbols at runtime, then our libraries are probably too old for your compiler. You may need to copy the libstdc++ and libgcc_s from your build system to the appropriate directory.<h3><a class="anchor" name="LIBRARIES_PROBE">
How To Install Libraries If You Use Probe-mode</a></h3>
If you are using probe mode, you cannot use the standard glibc on your system. Instead of installing pin-jit-runtime.tar.gz, you should install pin-probe-runtime.tar.gz. This runtime can be used for tools using probe or jit mode. The pin script expects to find glibc in the architecture-specific "runtime" subdirectory (i.e. ia32/runtime), so be careful about rearranging files and directories.<p>
The pin-probe-runtime requires using header files from glibc 2.3.4 and gcc 3.4.2 for compiling tools. The simplest way to do this is to install red hat el4 or one of its clones (c.g. centos) and use the system compiler.<h3><a class="anchor" name="LIBRARIES_PACKAGING">
Packaging Pintools For a Binary Distribution</a></h3>
If you are distributing pin tools in binary form, then we suggest that you preserve the layout of pin-jit-runtime.tar.gz:<p>
<div class="fragment"><pre class="fragment">ia32/runtime/glibc/
ia32/runtime/libgcc_s.so.1@
ia32/runtime/libstdc++.so.6.0.9*
ia32/runtime/libgcc_s-3.4.6-20060404.so.1*
ia32/runtime/libstdc++.so.6@
ia32/runtime/libgcc_s.so@
ia32/runtime/libstdc++.so.6.0.3*
</pre></div><p>
The "ia32" subdirectory is used for the IA-32 architecture. Similarly, "intel64" is used for the Intel(R) 64 architecture, and "ia64" is used for the IA-64 architecture.<h3><a class="anchor" name="LIBRARIES_DETAILS">
Detailed Explanation For Altering Directory Layout</a></h3>
We strongly recommend that you use an unmodified "pin" script and the library tar files that we provide. If you cannot then you will have to invest more time to understand the library requirements. Here is a brief explanation of the mechanism that the script uses:<p>
We have to modify the library paths so pin can find its libraries, but we don't want to affect the application. Pin uses these environment variables to control library paths.<p>
PIN_VM_LD_LIBRARY_PATH - LD_LIBRARY_PATH will be set to this value before starting vm or binary tool<p>
PIN_LD_RESTORE_REQUIRED - Tells injector, vm, or binary tool that it must restore the loader environment variables at startup, using the following variables.<p>
PIN_APP_LD_LIBRARY_PATH - LD_LIBRARY_PATH is restored to this value. If PIN_LD_RESTORE_REQUIRED is set, but this variable is not, then LD_LIBRARY_PATH will be unset.<p>
PIN_APP_LD_ASSUME_KERNEL - LD_ASSUME_KERNEL is restored to this value. If PIN_LD_RESTORE_REQUIRED is set, but this variable is not, then LD_ASSUME_KERNEL will be unset.<p>
The pin injector starts an application and then injects a vm into the address space of an application, and runs the application in the vm. The vm requires a binary, which we call "pinbin". The injector happens to be the same binary as the vm. When an injector starts up from the command line by invoking "pin", it needs the g++ libraries. If they are not in the standard place, then LD_LIBRARY_PATH must be set to point to them. The injector must use the standard glibc so don't point the LD_LIBRARY_PATH to the glibc that we redistribute.<p>
When an injector starts a vm, it must setup the library path by using PIN_LD_LIBRARY_PATH. This should point to the g++ libraries. If you are using probe mode, then it should also point to the glibc files.<p>
We don't want the application using any pin libraries so we restore the LD_LIBRARY_PATH before invoking the application by using PIN_LD_RESTORE_REQUIRED, PIN_OLD_LD_LIBRARY_PATH, and PIN_OLD_LD_ASSUME_KERNEL.<p>
See MIXED-MODE for more information on invoking Pin on Intel(R) 64 Architectures.<p>
======================================================================================== <h2><a class="anchor" name="RESTRICTIONS">
Unsupported features and restrictions</a></h2>
========================================================================================<h3><a class="anchor" name="General">
General</a></h3>
Each kit contains Pin and libraries for a specific architecture. Make sure the kit you download is for the right architecture. The Pin libraries use C++, and the compiler you use to build the tool must be compatible with the Pin library. This restriction only applies to building tools; you can instrument applications built by any compiler.<p>
See the README file in the kit for specific information about compiler version and other limitations. If your compiler is not compatible with the kit, send mail to <a href="mailto:pinheads@yahoogroups.com">pinheads@yahoogroups.com</a>.<h3><a class="anchor" name="Windows">
OS</a></h3>
Pin on Windows guarantees safe usage of C/C++ run-time services in Pin tools, including indirect calls to Windows API through C run-time library. Any other use of Windows API in Pin tool is not guaranteed to be safe:<ul>
<li>reentrant use of shared system resources may cause crashes and lost of transparency</li><li>a tool that directly or indirectly locks shared resource by calling to a system API under Pin lock may cause deadlock</li><li>using alertable system calls or installing handlers of asynchronous system events in a tool may violate the logic of the application, cause recursive invocation of instrumentation/analysis callbacks in the tool.</li></ul>
<p>
Pin on Windows does not separate DLLs loaded by the tool from the application DLLs - it uses the same system loader. In order to avoid isolation problems, Pin tool should not load any DLL that can be shared with the application. For the same reason, Pin tool should avoid static links to any common DLL, except for those listed in PIN_COMMON_LIBS (see source.flags file).<p>
In probe mode, the application runs natively, and the probe is placed in the original code. If a tool replaces a function shared by the tool and the application, an undesirable behavior may occur. For example, if a tool replaces EnterCriticalSection() with an analysis routine that calls printf(), this could result in an infinite loop, because printf() can also call EnterCriticalSection(). The application would call EnterCriticalSection(), and the control flow would go to the replacement routine, and it would call EnterCriticalSection() (via printf) which would call the replacement routine, and so on.<p>
======================================================================================== <h2><a class="anchor" name="FEEDBACK">
Questions? Bugs?</a></h2>
========================================================================================<p>
Send bugs and questions to <a href="mailto:pinheads@yahoogroups.com">pinheads@yahoogroups.com</a>. Complete bug reports that are easy to reproduce are fixed faster, so try to provide as much information as possible. Include: kit number, your OS version, compiler version. Try to reproduce the problem in a simple example that you can send us.<p>
======================================================================================== <h2><a class="anchor" name="LEGAL">
Disclaimer and Legal Information</a></h2>
========================================================================================<p>
The information in this manual is subject to change without notice and Intel Corporation assumes no responsibility or liability for any errors or inaccuracies that may appear in this document or any software that may be provided in association with this document. This document and the software described in it are furnished under license and may only be used or copied in accordance with the terms of the license. No license, express or implied, by estoppel or otherwise, to any intellectual property rights is granted by this document. The information in this document is provided in connection with Intel products and should not be construed as a commitment by Intel Corporation.<p>
EXCEPT AS PROVIDED IN INTEL'S TERMS AND CONDITIONS OF SALE FOR SUCH PRODUCTS, INTEL ASSUMES NO LIABILITY WHATSOEVER, AND INTEL DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTY, RELATING TO SALE AND/OR USE OF INTEL PRODUCTS INCLUDING LIABILITY OR WARRANTIES RELATING TO FITNESS FOR A PARTICULAR PURPOSE, MERCHANTABILITY, OR INFRINGEMENT OF ANY PATENT, COPYRIGHT OR OTHER INTELLECTUAL PROPERTY RIGHT. Intel products are not intended for use in medical, life saving, life sustaining, critical control or safety systems, or in nuclear facility applications.<p>
Designers must not rely on the absence or characteristics of any features or instructions marked "reserved" or "undefined." Intel reserves these for future definition and shall have no responsibility whatsoever for conflicts or incompat- ibilities arising from future changes to them.<p>
The software described in this document may contain software defects which may cause the product to deviate from published specifications. Current characterized software defects are available on request.<p>
Intel, the Intel logo, Intel SpeedStep, Intel NetBurst, Intel NetStructure, MMX, Intel386, Intel486, Celeron, Intel Centrino, Intel Xeon, Intel XScale, Itanium, Pentium, Pentium II Xeon, Pentium III Xeon, Pentium M, and VTune are trademarks or registered trademarks of Intel Corporation or its subsidiaries in the United States and other countries.<p>
Other names and brands may be claimed as the property of others.<p>
Copyright 2004-2008, Intel Corporation.<p>
======================================================================================== <hr size="1"><address style="align: right;"><small>Generated on Wed Dec 3 03:11:38 2008 for Pin by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.6 </small></address>
</body>
</html>
